Object subclass: #Etre	instanceVariableNames: ''	classVariableNames: ''	package: 'ICEO'!!Etre commentStamp: 'RB 3/19/2024 09:57' prior: 0!"Une essence est un être"!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Etre class	instanceVariableNames: 'structure situationDefinition isSituation isEtat etats etant nom id description'!!Etre class methodsFor: 'methodes' stamp: 'RB 2/28/2024 21:51'!resetStructure	structure := OrderedCollection new! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:54'!affecteEtat: uneQualite dansSituation: uneSituationIndividuelle	| etat |	uneQualite isQualite ifFalse: [		Exception new signal: uneQualite , 'n''est pas une qualité' ].	uneQualite getSituationDefinition	== uneSituationIndividuelle getEssence ifFalse: [		Exception new signal:			uneSituationIndividuelle , ' n''est pas instance de '			, uneQualite getSituationDefinition ].	self getEssence getQualites		detect: [ :each | each subsume: uneQualite ]		ifNone: [		Exception new signal: self getNom , ' ne peut être ' , uneQualite getNom].   	etat := uneQualite new.	self getEtats add: etat.	etat setEtant: self.	etat isEtat: true.	etat isSituation: false.	uneSituationIndividuelle add: etat.	etat setSituationDefinition: uneSituationIndividuelle.	"par défaut"	etat setNom: uneQualite getNom.	etat setDescription:		self getNom printString , ' addEtat: '		, uneQualite getNom printString , ' dansSituation: '		, uneSituationIndividuelle getNom printString.	Smalltalk at: #sib ifPresent: [ :x | x window close ] ! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:19'!attributionEtre: unStringOrSymbol essence: uneEssence	"Il faudra vérifier qu'il est prévu au niveau de l'essence de self d'avoir un attribut ayant comme essence uneEssence  "	| symbol attribut c n |	symbol := unStringOrSymbol isSymbol		          ifTrue: [ unStringOrSymbol ]		          ifFalse: [ unStringOrSymbol asSymbol ].	structure isNil ifTrue: [ structure := OrderedCollection new ].	structure		detect: [ :each |		each getNom == nom and: [ each getEssence == uneEssence ] ]		ifFound: [ :x |			Exception new signal:				'un être nommé ''' , x getNom , ' d''essence ' , uneEssence getNom				, ' est déjà attribut de ' , self getNom ].	attribut := uneEssence new.	attribut setNom: symbol.	structure add: attribut.	attribut setSituationDefinition: self.	uneEssence isIndividu ifTrue: [		uneEssence getAttributs do: [ :each |			c := each value.			(c notNil and: [ c > 0 ]) ifTrue: [				(1 to: c) do: [ :x |					n := uneEssence genSym: each key getNom.					attribut attributionEtre: n essence: each key ] ] ] ].	attribut class getQualites do: [ :each |		(each getStatut == #essentielle and: [			 each getEffectivite == #permanente ]) ifTrue: [			attribut affecteEtatEssentiel: each ] ].	attribut setDescription:		self getNom printString , ' attributionEtre ' , unStringOrSymbol		, ' essence: ' , uneEssence getNom printString.	Smalltalk at: #sib ifPresent: [ :x | x window close ] ! !!Etre class methodsFor: 'acces' stamp: 'RB 2/25/2024 21:23'!getEtresAttributsQuiSont: uneQualite 	| attributs |	attributs := OrderedCollection new.	self getEtats 		do: [:e |			e getEtresAttributs				do: [:ao | (ao getEssence == uneQualite							or: [ao getEssence getGenus == uneQualite])						ifTrue: [ao getEtant == nil								ifFalse: [attributs add: ao getEtant]]].			e getEtats				do: [:ao | ao getEtresAttributs						do: [:etat | (etat getEssence == uneQualite									or: [etat getEssence getGenus == uneQualite])								ifTrue: [etat getEtant == nil										ifFalse: [attributs add: etat getEtant]]]]].	^ attributs! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 11:38'!isSituation: aBoolean	isSituation := aBoolean! !!Etre class methodsFor: 'acces' stamp: 'RB 3/6/2024 18:41'!isEtat	isEtat isNil ifTrue: [isEtat := false].	^isEtat ! !!Etre class methodsFor: 'acces' stamp: 'RB 3/30/2024 09:08'!getEtresAttributsEnTantQue: uneQualite	| ee attributs |	attributs := OrderedCollection new.	ee := self getEtats.	ee do: [ :each |		each getEssence == uneQualite ifTrue: [			each getEtresAttributs do: [ :x |				x isEtat					ifTrue: [					x getEtant notNil ifTrue: [ attributs add: x getEtant ] ]					ifFalse: [ "x est un être attribut d'un état" attributs add: x ] ] ] ].	^ attributs! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:01'!affecteEtatEssentiel: uneQualite	"il faudra vérifier que self peut avoir cet etat !!!! "	| etat |	[	uneQualite isQualite ifFalse: [		Exception new signal: uneQualite , 'n''est pas une qualité' ].	etat := uneQualite new.	self getEtats add: etat.	etat setEtant: self.	etat isEtat: true.	etat isSituation: false.	etat setSituationDefinition: self.	"par défaut"	etat setNom: uneQualite getNom.	etat setDescription: self getNom printString , ' addEtatEssentiel: '		, uneQualite getNom printString.	Smalltalk at: #sib ifPresent: [ :x | x window close ] ]		on: Exception		do: [ :ex |			SpInformDialog new				title: '';				label: ex description;				acceptLabel: 'Ok';				openDialog ]! !!Etre class methodsFor: 'acces' stamp: 'RobertBourgeois 3/25/2024 08:05'!getEtres	^self getElements select: [:each | each isSituation not]! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 19:01'!setEtant: unEtre	etant := unEtre! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 12:14'!getNom	^nom! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 11:37'!isSituation	^isSituation! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 12:55'!getEssence	^self class! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:19'!get: unStringOrSymbol	"pour une situation"	"retourne, s'il existe, l'etre trouvé"	| symbol etres |	self isSituation ifFalse: [		Exception new signal: self getNom , ' n''est pas une situation' ].	symbol := unStringOrSymbol isSymbol		          ifTrue: [ unStringOrSymbol ]		          ifFalse: [ unStringOrSymbol asSymbol ].	etres := self getStructure select: [ :each | each getNom == symbol ].	etres size == 0 ifTrue: [		Exception new signal:			'être de nom' , symbol , ' non trouvé dans la situation '			, self getNom ].	etres size > 1 ifTrue: [		etres := self getStructure select: [ :each |			         each getNom == symbol and: [ each getEtats size == 0 ] ].		etres size == 0 ifTrue: [			Exception new signal: 'aucun être sans état de nom ' , symbol				, ' ne se trouve dans la situation ' , self getNom ] ].	etres size > 1 ifTrue: [		Exception new signal:			etres size printString , ' êtres de nom ' , symbol			, ' se trouvent dans la situation ' , self getNom ].	^ etres at: 1 ! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 12:13'!setNom: unSymbole	nom := unSymbole! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:27'!introductionEtre: unEtre"dans une situation"	self isSituation ifFalse: [		Exception new signal: self getNom , ' n''est pas une situation' ].	structure isNil ifTrue: [structure := OrderedCollection new].	structure add: unEtre! !!Etre class methodsFor: 'acces' stamp: 'RB 3/10/2024 22:40'!getId	" permet de différencier deux êtres de même nom"	id isNil ifTrue: [id := (self class genSym: nom)].	^id! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 18:56'!getEtats	etats isNil ifTrue: [etats := OrderedCollection new].	^etats! !!Etre class methodsFor: 'acces' stamp: 'RB 4/4/2024 10:54'!getElementsEssence: uneEssence"pour une situation, retourne l'ensemble des êtres ayant uneEssence pour essence"	^self getEtresAttributs select: [:each | each getEssence == uneEssence]   ! !!Etre class methodsFor: 'acces' stamp: 'RB 4/8/2024 16:02'!getEtats: unStringOrSymbol dansSituation: uneSituation 	|  e states symbol |	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	e := self getEtats.	states := e				select: [:each | (each getEssence getNom == symbol						and: [each isEtat])						and: [uneSituation getElements includes: each]].	^ states! !!Etre class methodsFor: 'acces' stamp: 'RB 2/19/2024 16:28'!isGenerique	^false! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:25'!getSituationGenerique	self isSituation ifFalse: [		Exception new signal: self getNom , ' n''est pas une situation' ].	^self class! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:22'!getSituations	"pour une situation"	| situations |	self isSituation ifFalse: [		Exception new signal:			'la méthode getSituations ne s''applique qu''à une situation' ].	situations := OrderedCollection new.	self getStructure do: [ :each |		each isSituation ifTrue: [ situations add: each ] ].	^ situations ! !!Etre class methodsFor: 'acces' stamp: 'RB 2/24/2024 19:15'!getStructure"pour un être"	structure isNil		ifTrue: [structure := OrderedCollection new].	^ structure! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:20'!get: unStringOrSymbol quiEst: uneQualite	"pour une situation"	"retourne, s'il existe avec la qualité uneQualité, l'etre trouvé"	| symbol etres |	self isSituation ifFalse: [		Exception new signal: self getNom , ' n''est pas une situation' ].	symbol := unStringOrSymbol isSymbol		          ifTrue: [ unStringOrSymbol ]		          ifFalse: [ unStringOrSymbol asSymbol ].	etres := self getStructure select: [ :each |		         each getNom == symbol and: [			         (each getEtat: uneQualite getNom) notNil ] ].	etres size == 0 ifTrue: [		Exception new signal:			'être de nom' , symbol , ' non trouvé dans la situation '			, self getNom ].	etres size > 1 ifTrue: [		Exception new signal:			etres size printString , ' êtres de nom ' , symbol			, ' se trouvent dans la situation ' , self getNom ].	^ etres at: 1 ! !!Etre class methodsFor: 'acces' stamp: 'RB 4/3/2024 14:48'!getAllEtresAttributs	| ee attributs |	"retourne les attributs propres de self et acquis dans ses états"	attributs := self getEtresAttributs.	ee := self getEtats.	ee do: [ :each |		each getEtresAttributs do: [ :x |			x isEtat				ifTrue: [ x getEtant notNil ifTrue: [ attributs add: x getEtant ] ]				ifFalse: [ "x est un être attribut d'un état" attributs add: x ] ].		each getEtats do: [ :other |			other getEtresAttributs do: [ :y |				y isEtat					ifTrue: [						y getEtant notNil ifTrue: [							y getEtant isEtat								ifTrue: [									y getEtant getEtant notNil ifTrue: [										attributs add: y getEtant getEtant ] ]								ifFalse: [ attributs add: y getEtant ] ] ]					ifFalse: [ attributs add: y ] ] ] ].	^ attributs! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:21'!getEtreAttribut: unStringOrSymbol	| attributs etre symbol |	symbol := unStringOrSymbol isSymbol		          ifTrue: [ unStringOrSymbol ]		          ifFalse: [ unStringOrSymbol asSymbol ].	attributs := self getEtresAttributs.	attributs		detect: [ :each |			each getNom == symbol or: [ each getEssence getNom == symbol ] ]		ifFound: [ :x | etre := x ]		ifNone: [			attributs do: [ :each |				each getEssence getAllGenus do: [ :x |					x getNom == symbol ifTrue: [ etre := each ] ] ] ].	etre isNil ifTrue: [		Exception new signal: 'attribut ' , symbol , ' non trouvé' ].	^ etre! !!Etre class methodsFor: 'acces' stamp: 'RB 3/19/2024 10:09'!getEtat: unStringOrSymbol dansSituation: uneSituation 	|  e etre symbol |	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	e := self getEtats.	etre := e				detect: [:each | (each getEssence getNom == symbol						and: [each isEtat])						and: [uneSituation getElements includes: each]].	^ etre! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:17'!associationEtat: unEtat	"association bidirectionnellle de self et de unEtat"	self isEtat ifFalse: [		Exception new signal: self getNom , ' n''est pas un   état' ].	unEtat isEtat ifFalse: [		Exception new signal: unEtat getNom , ' n''est pas un état' ].	self getSituationDefinition == unEtat getSituationDefinition		ifFalse: [			Exception new signal: unEtat getNom , ' et ' , self getNom				, ' ne sont pas définis dans la même situation' ].	self getEssence getDifferentia		detect: [ :each | each == unEtat getEssence ]		ifNone: [			Exception new signal:				'Association entre ' , self getNom , ' et ' , unEtat getNom				, ' non prévue' ].	self getStructure add: unEtat.	unEtat getStructure add: self! !!Etre class methodsFor: 'acces' stamp: 'RB 3/28/2024 14:26'!setDescription: unString	description := unString! !!Etre class methodsFor: 'acces' stamp: 'RB 2/24/2024 13:57'!getElements"pour une situation"	structure isNil		ifTrue: [structure := OrderedCollection new].	^ structure! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:18'!attributionEtre: unEtre	" change la situation de définition de unEtre.	cas du montage d'une pièce démontée d'un autre être  "	self getEssence getEssencesAttributs		detect: [ :each | each subsume: unEtre getEssence ]		ifFound: [ :a |			(self getStructure includes: unEtre)				ifTrue: [					Exception new signal:						'un être ' , unEtre , ' est déjà présente dans ' , self getNom ]				ifFalse: [					self getStructure add: unEtre.					unEtre setSituationDefinition: self ] ]		ifNone: [			Exception new signal:				unEtre getEssence getNom , ' non défini pour l''essence '				, self getEssence getNom ] ! !!Etre class methodsFor: 'acces' stamp: 'RB 4/4/2024 12:16'!getEtatEssence: uneEssence	| states |	states := etats				select: [:each | uneEssence subsume: each getEssence].	states size == 0		ifTrue: [^ nil].	^ states  at: 1! !!Etre class methodsFor: 'acces' stamp: 'RB 3/11/2024 08:50'!getEtat: unSymbole 	| states |	states := etats				select: [:each | each getNom == unSymbole].	states size == 0		ifTrue: [^ nil].	^ states  at: 1! !!Etre class methodsFor: 'acces' stamp: 'RB 2/28/2024 16:55'!removeEtat: unEtat		self getEtats remove: unEtat.! !!Etre class methodsFor: 'acces' stamp: 'RB 2/19/2024 18:32'!getSituationDefinition	^situationDefinition! !!Etre class methodsFor: 'acces' stamp: 'RB 2/28/2024 09:14'!setSituationDefinition: unEtre	situationDefinition := unEtre! !!Etre class methodsFor: 'acces' stamp: 'RB 4/15/2024 08:24'!getSituation: unSymbole 	"retourne, si elle existe, la première situation individuelle trouvée"	self isSituation ifFalse: [		Exception new signal: self getNom , ' n''est pas une situation' ].	^ structure		detect: [:each | each getNom == unSymbole asSymbol]! !!Etre class methodsFor: 'acces' stamp: 'RB 4/14/2024 20:57'!getEtresAttributs	| attributs |	structure isNil ifTrue: [ structure := OrderedCollection new ].	attributs := OrderedCollection new , structure.	self getEssence name ~~ #chose ifTrue: [		self getEssence getEtresAttributs do: [ :each |			each getEssence isPrototype ifTrue: [ attributs add: each ] ] ].	^ attributs! !!Etre class methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 07:29'!getDescription	^description isNil ifTrue: ['tbd'] ifFalse: [ description ]! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 19:01'!getEtant	^etant! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 11:37'!isEtat: aBoolean	isEtat := aBoolean! !Etre subclass: #Essence	instanceVariableNames: 'structure situationDefinition isSituation isEtat etats etant nom id description'	classVariableNames: ''	package: 'ICEO'!!Essence commentStamp: 'RB 3/19/2024 09:56' prior: 0!"superclass de toutes les essences et situations dans ICEO"!!Essence methodsFor: 'methodes' stamp: 'RB 2/28/2024 21:51'!resetStructure	structure := OrderedCollection new! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 09:02'!affecteEtat: uneQualite dansSituation: uneSituationIndividuelle	| etat |	uneQualite isQualite ifFalse: [		Exception new signal: uneQualite , 'n''est pas une qualité' ].	uneQualite getSituationDefinition	== uneSituationIndividuelle getEssence ifFalse: [		Exception new signal:			uneSituationIndividuelle , ' n''est pas instance de '			, uneQualite getSituationDefinition ].	self getEssence getQualites		detect: [ :each | each subsume: uneQualite ]		ifNone: [		Exception new signal: self getNom , ' ne peut être ' , uneQualite getNom].   	etat := uneQualite new.	self getEtats add: etat.	etat setEtant: self.	etat isEtat: true.	etat isSituation: false.	uneSituationIndividuelle introductionEtre: etat.	etat setSituationDefinition: uneSituationIndividuelle.	"par défaut"	etat setNom: uneQualite getNom.	etat setDescription:		self getNom printString , ' addEtat: '		, uneQualite getNom printString , ' dansSituation: '		, uneSituationIndividuelle getNom printString.	Smalltalk at: #sib ifPresent: [ :x | x window close ] ! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 08:19'!attributionEtre: unStringOrSymbol essence: uneEssence	"Il faudra vérifier qu'il est prévu au niveau de l'essence de self d'avoir un attribut ayant comme essence uneEssence  "	| symbol attribut c n |	symbol := unStringOrSymbol isSymbol		          ifTrue: [ unStringOrSymbol ]		          ifFalse: [ unStringOrSymbol asSymbol ].	structure isNil ifTrue: [ structure := OrderedCollection new ].	structure		detect: [ :each |		each getNom == nom and: [ each getEssence == uneEssence ] ]		ifFound: [ :x |			Exception new signal:				'un être nommé ''' , x getNom , ' d''essence ' , uneEssence getNom				, ' est déjà attribut de ' , self getNom ].	attribut := uneEssence new.	attribut setNom: symbol.	structure add: attribut.	attribut setSituationDefinition: self.	uneEssence isIndividu ifTrue: [		uneEssence getAttributs do: [ :each |			c := each value.			(c notNil and: [ c > 0 ]) ifTrue: [				(1 to: c) do: [ :x |					n := uneEssence genSym: each key getNom.					attribut attributionEtre: n essence: each key ] ] ] ].	attribut class getQualites do: [ :each |		(each getStatut == #essentielle and: [			 each getEffectivite == #permanente ]) ifTrue: [			attribut affecteEtatEssentiel: each ] ].	attribut setDescription:		self getNom printString , ' attributionEtre ' , unStringOrSymbol		, ' essence: ' , uneEssence getNom printString.	Smalltalk at: #sib ifPresent: [ :x | x window close ] ! !!Essence methodsFor: 'acces' stamp: 'RB 2/25/2024 21:23'!getEtresAttributsQuiSont: uneQualite 	| attributs |	attributs := OrderedCollection new.	self getEtats 		do: [:e |			e getEtresAttributs				do: [:ao | (ao getEssence == uneQualite							or: [ao getEssence getGenus == uneQualite])						ifTrue: [ao getEtant == nil								ifFalse: [attributs add: ao getEtant]]].			e getEtats				do: [:ao | ao getEtresAttributs						do: [:etat | (etat getEssence == uneQualite									or: [etat getEssence getGenus == uneQualite])								ifTrue: [etat getEtant == nil										ifFalse: [attributs add: etat getEtant]]]]].	^ attributs! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 11:38'!isSituation: aBoolean	isSituation := aBoolean! !!Essence methodsFor: 'acces' stamp: 'RB 3/6/2024 18:41'!isEtat	isEtat isNil ifTrue: [isEtat := false].	^isEtat ! !!Essence methodsFor: 'acces' stamp: 'RB 3/30/2024 09:08'!getEtresAttributsEnTantQue: uneQualite	| ee attributs |	attributs := OrderedCollection new.	ee := self getEtats.	ee do: [ :each |		each getEssence == uneQualite ifTrue: [			each getEtresAttributs do: [ :x |				x isEtat					ifTrue: [					x getEtant notNil ifTrue: [ attributs add: x getEtant ] ]					ifFalse: [ "x est un être attribut d'un état" attributs add: x ] ] ] ].	^ attributs! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 07:57'!affecteEtatEssentiel: uneQualite	| etat |	uneQualite isQualite ifFalse: [		Exception new signal: uneQualite , 'n''est pas une qualité' ].	self getEssence getQualites		detect: [ :each | each subsume: uneQualite ]		ifNone: [		Exception new signal: self getNom , ' ne peut être ' , uneQualite getNom].	uneQualite isEssentielle  ifFalse: [		Exception new signal: uneQualite , 'n''est pas essentielle' ].	etat := uneQualite new.	self getEtats add: etat.	etat setEtant: self.	etat isEtat: true.	etat isSituation: false.	etat setSituationDefinition: self.	"par défaut"	etat setNom: uneQualite getNom.	etat setDescription: self getNom printString , ' addEtatEssentiel: '		, uneQualite getNom printString.	Smalltalk at: #sib ifPresent: [ :x | x window close ] ! !!Essence methodsFor: 'acces' stamp: 'RobertBourgeois 3/25/2024 08:05'!getEtres	^self getElements select: [:each | each isSituation not]! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 19:01'!setEtant: unEtre	etant := unEtre! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 12:14'!getNom	^nom! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 11:37'!isSituation	^isSituation! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 12:55'!getEssence	^self class! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 08:19'!get: unStringOrSymbol	"pour une situation"	"retourne, s'il existe, l'etre trouvé"	| symbol etres |	self isSituation ifFalse: [		Exception new signal: self getNom , ' n''est pas une situation' ].	symbol := unStringOrSymbol isSymbol		          ifTrue: [ unStringOrSymbol ]		          ifFalse: [ unStringOrSymbol asSymbol ].	etres := self getStructure select: [ :each | each getNom == symbol ].	etres size == 0 ifTrue: [		Exception new signal:			'être de nom' , symbol , ' non trouvé dans la situation '			, self getNom ].	etres size > 1 ifTrue: [		etres := self getStructure select: [ :each |			         each getNom == symbol and: [ each getEtats size == 0 ] ].		etres size == 0 ifTrue: [			Exception new signal: 'aucun être sans état de nom ' , symbol				, ' ne se trouve dans la situation ' , self getNom ] ].	etres size > 1 ifTrue: [		Exception new signal:			etres size printString , ' êtres de nom ' , symbol			, ' se trouvent dans la situation ' , self getNom ].	^ etres at: 1 ! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 12:13'!setNom: unSymbole	nom := unSymbole! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 08:26'!introductionEtre: unEtre"dans une situation"	self isSituation ifFalse: [		Exception new signal: self getNom , ' n''est pas une situation' ].	structure isNil ifTrue: [structure := OrderedCollection new].	structure add: unEtre! !!Essence methodsFor: 'acces' stamp: 'RB 3/10/2024 22:40'!getId	" permet de différencier deux êtres de même nom"	id isNil ifTrue: [id := (self class genSym: nom)].	^id! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 18:56'!getEtats	etats isNil ifTrue: [etats := OrderedCollection new].	^etats! !!Essence methodsFor: 'acces' stamp: 'RB 4/4/2024 10:54'!getElementsEssence: uneEssence"pour une situation, retourne l'ensemble des êtres ayant uneEssence pour essence"	^self getEtresAttributs select: [:each | each getEssence == uneEssence]   ! !!Essence methodsFor: 'acces' stamp: 'RB 4/8/2024 16:02'!getEtats: unStringOrSymbol dansSituation: uneSituation 	|  e states symbol |	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	e := self getEtats.	states := e				select: [:each | (each getEssence getNom == symbol						and: [each isEtat])						and: [uneSituation getElements includes: each]].	^ states! !!Essence methodsFor: 'acces' stamp: 'RB 2/19/2024 16:28'!isGenerique	^false! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 08:25'!getSituationGenerique	self isSituation ifFalse: [		Exception new signal: self getNom , ' n''est pas une situation' ].	^self class! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 08:22'!getSituations	"pour une situation"	| situations |	self isSituation ifFalse: [		Exception new signal:			'la méthode getSituations ne s''applique qu''à une situation' ].	situations := OrderedCollection new.	self getStructure do: [ :each |		each isSituation ifTrue: [ situations add: each ] ].	^ situations ! !!Essence methodsFor: 'acces' stamp: 'RB 2/24/2024 19:15'!getStructure"pour un être"	structure isNil		ifTrue: [structure := OrderedCollection new].	^ structure! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 08:20'!get: unStringOrSymbol quiEst: uneQualite	"pour une situation"	"retourne, s'il existe avec la qualité uneQualité, l'etre trouvé"	| symbol etres |	self isSituation ifFalse: [		Exception new signal: self getNom , ' n''est pas une situation' ].	symbol := unStringOrSymbol isSymbol		          ifTrue: [ unStringOrSymbol ]		          ifFalse: [ unStringOrSymbol asSymbol ].	etres := self getStructure select: [ :each |		         each getNom == symbol and: [			         (each getEtat: uneQualite getNom) notNil ] ].	etres size == 0 ifTrue: [		Exception new signal:			'être de nom' , symbol , ' non trouvé dans la situation '			, self getNom ].	etres size > 1 ifTrue: [		Exception new signal:			etres size printString , ' êtres de nom ' , symbol			, ' se trouvent dans la situation ' , self getNom ].	^ etres at: 1 ! !!Essence methodsFor: 'acces' stamp: 'RB 4/3/2024 14:48'!getAllEtresAttributs	| ee attributs |	"retourne les attributs propres de self et acquis dans ses états"	attributs := self getEtresAttributs.	ee := self getEtats.	ee do: [ :each |		each getEtresAttributs do: [ :x |			x isEtat				ifTrue: [ x getEtant notNil ifTrue: [ attributs add: x getEtant ] ]				ifFalse: [ "x est un être attribut d'un état" attributs add: x ] ].		each getEtats do: [ :other |			other getEtresAttributs do: [ :y |				y isEtat					ifTrue: [						y getEtant notNil ifTrue: [							y getEtant isEtat								ifTrue: [									y getEtant getEtant notNil ifTrue: [										attributs add: y getEtant getEtant ] ]								ifFalse: [ attributs add: y getEtant ] ] ]					ifFalse: [ attributs add: y ] ] ] ].	^ attributs! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 08:21'!getEtreAttribut: unStringOrSymbol	| attributs etre symbol |	symbol := unStringOrSymbol isSymbol		          ifTrue: [ unStringOrSymbol ]		          ifFalse: [ unStringOrSymbol asSymbol ].	attributs := self getEtresAttributs.	attributs		detect: [ :each |			each getNom == symbol or: [ each getEssence getNom == symbol ] ]		ifFound: [ :x | etre := x ]		ifNone: [			attributs do: [ :each |				each getEssence getAllGenus do: [ :x |					x getNom == symbol ifTrue: [ etre := each ] ] ] ].	etre isNil ifTrue: [		Exception new signal: 'attribut ' , symbol , ' non trouvé' ].	^ etre! !!Essence methodsFor: 'acces' stamp: 'RB 3/19/2024 10:09'!getEtat: unStringOrSymbol dansSituation: uneSituation 	|  e etre symbol |	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	e := self getEtats.	etre := e				detect: [:each | (each getEssence getNom == symbol						and: [each isEtat])						and: [uneSituation getElements includes: each]].	^ etre! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 10:06'!associationEtat: unEtat	"association bidirectionnellle de self et de unEtat"	self isEtat ifFalse: [		Exception new signal: self getNom , ' n''est pas un   état' ].	unEtat isEtat ifFalse: [		Exception new signal: unEtat getNom , ' n''est pas un état' ].	self getEssence getDifferentia		detect: [ :each | each == unEtat getEssence ]		ifNone: [			Exception new signal:				'Association entre ' , self getNom , ' et ' , unEtat getNom				, ' non prévue' ].	self getStructure add: unEtat.	unEtat getStructure add: self! !!Essence methodsFor: 'acces' stamp: 'RB 3/28/2024 14:26'!setDescription: unString	description := unString! !!Essence methodsFor: 'acces' stamp: 'RB 2/24/2024 13:57'!getElements"pour une situation"	structure isNil		ifTrue: [structure := OrderedCollection new].	^ structure! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 08:18'!attributionEtre: unEtre	" change la situation de définition de unEtre.	cas du montage d'une pièce démontée d'un autre être  "	self getEssence getEssencesAttributs		detect: [ :each | each subsume: unEtre getEssence ]		ifFound: [ :a |			(self getStructure includes: unEtre)				ifTrue: [					Exception new signal:						'un être ' , unEtre , ' est déjà présente dans ' , self getNom ]				ifFalse: [					self getStructure add: unEtre.					unEtre setSituationDefinition: self ] ]		ifNone: [			Exception new signal:				unEtre getEssence getNom , ' non défini pour l''essence '				, self getEssence getNom ] ! !!Essence methodsFor: 'acces' stamp: 'RB 4/4/2024 12:16'!getEtatEssence: uneEssence	| states |	states := etats				select: [:each | uneEssence subsume: each getEssence].	states size == 0		ifTrue: [^ nil].	^ states  at: 1! !!Essence methodsFor: 'acces' stamp: 'RB 3/11/2024 08:50'!getEtat: unSymbole 	| states |	states := etats				select: [:each | each getNom == unSymbole].	states size == 0		ifTrue: [^ nil].	^ states  at: 1! !!Essence methodsFor: 'acces' stamp: 'RB 2/28/2024 16:55'!removeEtat: unEtat		self getEtats remove: unEtat.! !!Essence methodsFor: 'acces' stamp: 'RB 2/19/2024 18:32'!getSituationDefinition	^situationDefinition! !!Essence methodsFor: 'acces' stamp: 'RB 2/28/2024 09:14'!setSituationDefinition: unEtre	situationDefinition := unEtre! !!Essence methodsFor: 'acces' stamp: 'RB 4/15/2024 08:24'!getSituation: unSymbole 	"retourne, si elle existe, la première situation individuelle trouvée"	self isSituation ifFalse: [		Exception new signal: self getNom , ' n''est pas une situation' ].	^ structure		detect: [:each | each getNom == unSymbole asSymbol]! !!Essence methodsFor: 'acces' stamp: 'RB 4/14/2024 20:58'!getEtresAttributs	| attributs |	structure isNil ifTrue: [ structure := OrderedCollection new ].	attributs := OrderedCollection new , structure.	self getEssence name ~~ #chose ifTrue: [		self getEssence getEtresAttributs do: [ :each |			each getEssence isPrototype ifTrue: [ attributs add: each ] ] ].	^ attributs! !!Essence methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 07:29'!getDescription	^description isNil ifTrue: ['tbd'] ifFalse: [ description ]! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 19:01'!getEtant	^etant! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 11:37'!isEtat: aBoolean	isEtat := aBoolean! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Essence class	instanceVariableNames: 'differentia isQualite isIndividu isPrototype statut effectivite qualites essencesQualifiees metaEssence'!!Essence class methodsFor: 'acces' stamp: 'RB 2/23/2024 12:45'!setMetaEssence: uneEssence	metaEssence := uneEssence! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 11:32'!isSituation: aBoolean	isSituation := aBoolean! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 10:51'!isChose	^ self getAllGenus		detect: [:each | each name == #chose]		ifFound: [:x | true]		ifNone: [false]! !!Essence class methodsFor: 'acces' stamp: 'RB 2/18/2024 23:56'!setStatut: unSymbole 	statut := (OrderedCollection with: #accidentelle with: #essentielle)				detect: [:i | i = unSymbole]! !!Essence class methodsFor: 'acces' stamp: 'RB 2/15/2024 11:37'!getNom	^ name! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 21:29'!isSituation	isSituation isNil		ifTrue: [isSituation := false].	^ isSituation! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:44'!getQualitesAssociees	| attributs temp |	(self isSituation or: [ self isQualite not ]) ifTrue: [		Exception new signal:			'la méthode getQualitesAssociees ne s''applique qu''à une qualité' ].	attributs := OrderedCollection new.	(self ~~ Essence and: [ superclass ~~ (Smalltalk at: #chose) ])		ifTrue: [ attributs addAll: superclass getQualitesAssociees ].	self getDifferentia do: [ :each |		each class name ~~ #Association ifTrue: [ attributs add: each ] ].	"ne garder que les attributs non surchargés"	temp := OrderedCollection new.	attributs do: [ :each | temp add: each ].	attributs do: [ :each |		attributs do: [ :att |			(att getAllGenusWithoutMe includes: each) ifTrue: [				temp remove: each ifAbsent: [  ] ] ] ].	^ temp ! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:41'!getEssenceAttribut: unStringOrSymbol	| attributs symbole |	symbole := unStringOrSymbol isSymbol		           ifTrue: [ unStringOrSymbol ]		           ifFalse: [ unStringOrSymbol asSymbol ].	attributs := self getEssencesAttributs select: [ :each |		             each name == symbole ].	attributs size == 0 ifTrue: [		self getEssencesAttributs do: [ :each |			each getAllGenus do: [ :sup |				sup name == symbole ifTrue: [ attributs add: each ] ] ] ].	attributs size == 0 ifTrue: [		Exception new signal:			self name , ' ne possède pas d''attribut de nom ' , symbole			, '  ou subsumé par ' , symbole ].	attributs size > 1 ifTrue: [		Exception new signal:			self name , ' possède ' , attributs size printString			, ' attributs de nom ' , symbole , '  ou subsumés par ' , symbole ].	^ attributs at: 1 ! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 10:15'!resetDifferentia	differentia := OrderedCollection new! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 17:30'!getStatut	statut isNil ifTrue: [statut := #accidentelle].	^statut! !!Essence class methodsFor: 'acces' stamp: 'RB 2/24/2024 14:08'!get: unStringOrSymbol 	"retourne l'essence unStringOrSymbol incluse dans une situation"	^self getElement: unStringOrSymbol! !!Essence class methodsFor: 'acces' stamp: 'RB 2/24/2024 13:56'!getEssence	"par défaut, l'essence d'une essence est l'essence chose"	metaEssence == nil		ifTrue: [metaEssence := Smalltalk at: #chose].	^ metaEssence! !!Essence class methodsFor: 'acces' stamp: 'RB 2/28/2024 08:55'!isIndividu: aBoolean"true par défaut" isIndividu := aBoolean! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 10:54'!getMetaEssence	^metaEssence! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 22:11'!getId	" permet de différencier deux essences de même nom"	id isNil ifTrue: [id := (self genSym: name)].	^id! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:40'!getElement: unStringOrSymbol	"retourne l'essence unStringOrSymbol incluse dans une situation"	| n |	self isSituation ifFalse: [		Exception new signal:			'la méthode getEssence: ne s''applique qu''à une situation' ].	n := unStringOrSymbol isSymbol		     ifTrue: [ unStringOrSymbol ]		     ifFalse: [ unStringOrSymbol asSymbol ].	^ differentia		  detect: [ :each | each name == n and: [ each isSituation not ] ]		  ifNone: [			  Exception new signal:				  'essence ' , n , ' non trouvée dans la situation ' , self name ] ! !!Essence class methodsFor: 'acces' stamp: 'RB 2/22/2024 18:25'!isPrototype: aBoolean	isPrototype := aBoolean! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:45'!isGenerique	self isSituation ifFalse: [		Exception new signal: 'seule une situation peut être générique' ].	^ true ! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:45'!getSituations	"pour une situation"	| situations |	self isSituation ifFalse: [		Exception new signal:			'la méthode getSituations ne s''applique qu''à une situation' ].	situations := OrderedCollection new.	self getDifferentia do: [ :each |		each isSituation ifTrue: [ situations add: each ] ].	^ situations ! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 18:14'!setEffectivite: unSymbole	effectivite := (OrderedCollection with: #permanente  with: #intermittente) detect: [:i | i = unSymbole]! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 12:57'!getAllGenus	| c |	(self name == #Essence			or: [self name == #absolu])		ifTrue: [^ OrderedCollection new].	c := OrderedCollection with: self.	self name == #chose		ifFalse: [c addAll: self getGenus getAllGenus].	^ c! !!Essence class methodsFor: 'acces' stamp: 'RB 3/24/2024 09:55'!isEssentielle	statut isNil ifTrue: [^false].	^self getStatut == #essentielle  ! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 04:11'!getDifferentia	"retourne l'ensemble des attributs propres"	differentia isNil ifTrue: [ differentia := OrderedCollection new] .	^ differentia! !!Essence class methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 07:32'!setDescription: aString	description := aString! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 21:15'!isQualite isQualite isNil ifTrue: [isQualite := false].^isQualite! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:39'!getAttributs	"attributs (instances d'Association) propres et hérités mais non surchargées pour une essence"	| attributs temp |	self isSituation ifTrue: [		Exception new signal:			'la méthode getAttributs ne s''applique qu''à une essence' ].	attributs := OrderedCollection new.	(self ~~ Essence and: [ superclass ~~ (Smalltalk at: #chose) ])		ifTrue: [ attributs addAll: superclass getAttributs ].	self getDifferentia do: [ :each |		each class name == #Association ifTrue: [ attributs add: each ] ].	"ne garder que les attributs non surchargés"	temp := OrderedCollection new.	attributs do: [ :each | temp add: each ].	attributs do: [ :each |		attributs do: [ :att |			(att key getAllGenusWithoutMe includes: each key) ifTrue: [				temp remove: each ifAbsent: [  ] ] ] ].	^ temp ! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:41'!getElements: uneEssence	"retourne l'ensemble des éléments inclus dans une situation"	self isSituation		ifTrue: [		^ self getDifferentia select: [ :each | uneEssence subsume: each ] ]		ifFalse: [			Exception new signal:				'la méthode getElements ne s''applique qu''à une situation' ] ! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:41'!getElements	"retourne l'ensemble des éléments inclus dans une situation"	self isSituation		ifTrue: [ ^ self getDifferentia ]		ifFalse: [			Exception new signal:				'la méthode getElements ne s''applique qu''à une situation' ] ! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:43'!getQualite: unStringOrSymbol	"retourne l'essence unStringOrSymbol incluse dans les qualités d'une essence "	| n |	n := unStringOrSymbol isSymbol		     ifTrue: [ unStringOrSymbol ]		     ifFalse: [ unStringOrSymbol asSymbol ].	^ self getQualites detect: [ :each | each name == n ] ifNone: [		  Exception new signal:			  'qualité ' , unStringOrSymbol , ' non trouvée pour ' , name ] ! !!Essence class methodsFor: 'acces' stamp: 'RB 4/7/2024 17:46'!getEssences	" pour une situation "	^self getElements select: [:each | each isSituation not]! !!Essence class methodsFor: 'acces' stamp: 'RB 4/3/2024 09:30'!isIndividu	isIndividu isNil ifTrue: [		((self isSituation or: [ self isQualite ]) or: [			 self getSituationDefinition isSituation not ])			ifTrue: [ isIndividu := false ]			ifFalse: [ isIndividu := true ] ].	^ isIndividu! !!Essence class methodsFor: 'acces' stamp: 'RB 2/15/2024 13:12'!getGenus	^ name == #chose		ifTrue: [self]		ifFalse: [superclass]! !!Essence class methodsFor: 'acces' stamp: 'RB 4/9/2024 12:02'!getEssencesAttributs| col |	col := self getAttributs collect: [:each | each key ].	self isQualite ifTrue: [col addAll: self getQualitesAssociees].	^col ! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 11:32'!isQualite: aBoolean	isQualite := aBoolean! !!Essence class methodsFor: 'acces' stamp: 'RB 4/7/2024 19:24'!getAllGenusWithoutMe	^ self getAllGenus copyWithout: self	! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 10:17'!setId: unSymbole	" permet de différencier deux essences de même nom pour nous, pauvres lecteurs humains"	id := unSymbole! !!Essence class methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 06:54'!getSituationDefinition		^situationDefinition! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:43'!getQualites	"qualités propres et héritées mais non surchargées pour une essence"	| me temp |	self isSituation ifTrue: [		Exception new signal:			'la méthode getQualites ne s''applique qu''à une essence' ].	qualites isNil ifTrue: [ qualites := OrderedCollection new ].	me := qualites collect: [ :each | each ].	superclass == (Smalltalk at: #Essence) ifFalse: [		me addAll: superclass getQualites ].	"ne garder que les qualites non surchargées"	temp := me collect: [ :each | each ].	me do: [ :each |		me do: [ :q |			(q getAllGenusWithoutMe includes: each) ifTrue: [				temp remove: each ifAbsent: [  ] ] ] ].	^ temp ! !!Essence class methodsFor: 'acces' stamp: 'RB 2/24/2024 16:22'!isPrototype	isPrototype == nil ifTrue: [isPrototype := false]. ^isPrototype! !!Essence class methodsFor: 'acces' stamp: 'RB 2/15/2024 12:34'!setSituationDefinition: uneEssence	situationDefinition := uneEssence! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:38'!getAttribut: unStringOrSymbol	| attributs symbole |	symbole := unStringOrSymbol isSymbol		           ifTrue: [ unStringOrSymbol ]		           ifFalse: [ unStringOrSymbol asSymbol ].	attributs := self getAttributs select: [ :each |		             each key name == symbole ].	attributs size == 0 ifTrue: [		self getAttributs do: [ :each |			each key getAllGenus do: [ :sup |				sup name == symbole ifTrue: [ attributs add: each ] ] ] ].	attributs size == 0 ifTrue: [		Exception new signal:			self name , ' ne possède pas d''attribut de nom ' , symbole			, '  ou subsumé par ' , symbole ].	attributs size > 1 ifTrue: [		Exception new signal:			self name , ' possède ' , attributs size printString			, ' attributs de nom ' , symbole , '  ou subsumés par ' , symbole ].	^ attributs at: 1 ! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:44'!getQualitesPropres	self isSituation ifTrue: [		Exception new signal:			'la méthode getQualites ne s''applique qu''à une essence' ].	qualites isNil ifTrue: [ qualites := OrderedCollection new ].	^ qualites ! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 10:08'!associationQualite: uneQualite	"association binaire et bidirectionnellle de self et de uneQualite"	self isQualite ifFalse: [		Exception new signal: self getNom , ' n''est pas une qualité' ].	uneQualite isQualite ifFalse: [		Exception new signal: uneQualite getNom , ' n''est pas une qualité' ].	self getDifferentia add: uneQualite.	" attribution corrélative, sauf s'il s'agit d'une qualite de self. Par exemple, être soeur pour une soeur ... "	self == uneQualite ifFalse: [ uneQualite getDifferentia add: self ]! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 17:31'!getEffectivite	effectivite isNil ifTrue: [effectivite := #intermittente].	^effectivite! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:44'!getSituation: unStringOrSymbol	"retourne la situation unStringOrSymbol incluse dans une situation"	| n env |	self isSituation ifFalse: [		Exception new signal:			'la méthode getEssences: ne s''applique qu''à une situation' ].	n := unStringOrSymbol isSymbol		     ifTrue: [ unStringOrSymbol ]		     ifFalse: [ unStringOrSymbol asSymbol ].	env := self getDifferentia collect: [ :each | each value ].	^ env		  detect: [ :each |			  each name == n and: [ each isBehavior and: [ each isSituation ] ] ]		  ifNone: [			  Exception new signal:				  'situation ' , n , ' non trouvée dans la situation ' , self name ] ! !!Essence class methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 07:31'!getDescription	^description isNil ifTrue: ['tbd'] ifFalse: [ description ]! !!Essence class methodsFor: 'acces' stamp: 'RB 4/15/2024 07:42'!getEssencesAttributs: unSymbole	| attributs |	attributs := self getEssencesAttributs select: [ :each |		             each name == unSymbole ].	attributs size == 0 ifTrue: [		self getEssencesAttributs do: [ :each |			each allSuperclasses do: [ :sup |				sup name == unSymbole ifTrue: [ attributs add: each ] ] ] ].	attributs size == 0 ifTrue: [		Exception new signal:			self name , ' ne possède pas d''attribut de nom ' , unSymbole ].	^ attributs ! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 17:58'!getEssencesQualifiees	essencesQualifiees isNil ifTrue: [essencesQualifiees := OrderedCollection new].	 	^essencesQualifiees! !!Essence class methodsFor: 'methodes' stamp: 'RB 4/15/2024 07:46'!referenceEssence: uneEssence cardinalite: anInteger	"ne change pas la situation de définition de une essence"	(self getDifferentia includes: uneEssence getNom)		ifTrue: [			Exception new signal:				'une essence de nom ' , uneEssence , ' est déjà présente dans '				, self getNom ]		ifFalse: [			self getDifferentia add:				(Association key: uneEssence value: anInteger) ] ! !!Essence class methodsFor: 'methodes' stamp: 'RB 4/15/2024 07:38'!est: uneQualite	uneQualite isQualite ifFalse: [		Exception new signal: uneQualite , ' n''est pas une qualité' ].	uneQualite getStatut == #essentielle ifFalse: [		Exception new signal:			uneQualite , ' n''est pas une qualité essentielle' ].	qualites isNil ifTrue: [ qualites := OrderedCollection new ].	qualites add: uneQualite.	uneQualite getEssencesQualifiees add: self! !!Essence class methodsFor: 'methodes' stamp: 'RB 4/4/2024 08:58'!referenceEssence: uneEssence 	"ne change pas la situation de définition de l'essence"	self referenceEssence: uneEssence cardinalite: nil! !!Essence class methodsFor: 'methodes' stamp: 'RB 2/26/2024 18:21'!getInstance: unStringOrSymbol 	"création d'un être hypothétique instance de self "	| symbol etre |	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	etre := self new.	etre setNom: symbol.	etre isSituation: false.	etre isEtat: false.	^etre		! !!Essence class methodsFor: 'methodes' stamp: 'RB 2/26/2024 16:45'!specialise: uneEssence 	^self allSuperclasses includes: uneEssence  		! !!Essence class methodsFor: 'methodes' stamp: 'RB 4/15/2024 07:46'!peutEtre: uneQualite	uneQualite isQualite ifFalse: [		Exception new signal: uneQualite getNom , ' n''est pas une qualité' ].	qualites isNil ifTrue: [ qualites := OrderedCollection new ].	qualites add: uneQualite.	uneQualite getEssencesQualifiees add: self ! !!Essence class methodsFor: 'methodes' stamp: 'RB 4/4/2024 13:16'!subsume: uneEssence 	self == uneEssence		ifTrue: [^ true].	(uneEssence getNom == #chose or: [uneEssence getNom == #Essence ] )		ifTrue: [^ false].	^ self subsume: uneEssence getGenus! !!Essence class methodsFor: 'utile' stamp: 'RB 3/19/2024 11:54'!genSym: aSymb 	"generateur de symboles"	| n gs |	gs := Smalltalk at: #GenSym.	n := gs at: aSymb ifAbsent: [n := -1].	n := n + 1.	gs at: aSymb put: n.	^(aSymb , '_', n printString) asSymbol! !!Essence class methodsFor: 'utile' stamp: 'RB 3/19/2024 14:46'!createFreeSubclass: aSymbol	| newClass |	"not installed in the system"	newClass := self newAnonymousSubclass setName: aSymbol.	subclasses isNil		ifTrue: [ self subclasses: (Array with: newClass) ]		ifFalse: [ self subclasses: (subclasses copyWith: newClass) ].	^ newClass! !Object subclass: #ICEO	instanceVariableNames: ''	classVariableNames: ''	package: 'ICEO'!!ICEO commentStamp: 'RB 3/19/2024 09:54' prior: 0!"Interprète du langage ICEO"!!ICEO methodsFor: 'etres' stamp: 'RB 4/15/2024 08:51'!soit: unStringOrSymbol essence: uneEssence situationIndividuelle: uneSituation	"définition dans uneSituationIndividuelle d'un être d'essence	uneEssence"	| nom etre c n |	Smalltalk at: #sib ifPresent: [:x | x window close].		nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	uneSituation getElements		detect: [ :each |		each getNom == nom and: [ each getEssence == uneEssence ] ]		ifFound: [ :x |			Exception new signal: 'un être nommé ''' , x				, ''' de même essence existe déjà dans la situation'				, uneSituation ].	etre := uneEssence new.	etre setNom: nom.	etre setSituationDefinition: uneSituation.	uneSituation introductionEtre: etre.	etre isSituation: false.	etre isEtat: false.	"création des attributs dont la cardinalite est définie et > 0"	uneEssence isIndividu ifTrue: [		uneEssence getAttributs do: [ :each |			c := each value.			(c notNil and: [ c > 0 ]) ifTrue: [				(1 to: c) do: [ :x |					n := uneEssence genSym: each key getNom.					self soitAttribut: n de: etre essence: each key] ] ] ].	"les états essentiels se situent dans la situation de définition l'être"	uneEssence getQualites do: [ :each |		(each getStatut == #essentielle and: [			 each getEffectivite == #permanente ]) ifTrue: [			etre affecteEtatEssentiel: each  ] ].	etre setDescription: 'soit: ', nom, ' essence: ', uneEssence getNom, ' situationIndividuelle: ', uneSituation getNom printString.	^ etre! !!ICEO methodsFor: 'etres' stamp: 'RB 4/15/2024 08:51'!soit: unStringOrSymbol essence: uneEssence situationIndividuelle: uneSituation quiEst: uneQualite	"définition dans uneSituationIndividuelle d'un être d'essence uneEssence ayant un état instance de uneQualité"	| nom etre c n |	Smalltalk at: #sib ifPresent: [:x | x window close].			nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	" deux êtres de même nom ne peuvent exister dans la même situation s'ils ne se distinguent pas par leur état"	uneSituation getElements		detect: [ :each |			(each getNom == nom and: [ each getEssence == uneEssence ]) and: [				(each getEtat: uneQualite getNom) notNil ] ]		ifFound: [ :x |			Exception new signal: 'un être nommé ''' , x getNom				, ''' de même essence existe déjà dans la situation'				, uneSituation , ' avec la même qualité ' , uneQualite getNom ].	etre := uneEssence new.	etre setNom: nom.	etre setSituationDefinition: uneSituation.	uneSituation introductionEtre: etre.	etre isSituation: false.	etre isEtat: false.	(Smalltalk at: #monde) add: etre.	etre affecteEtat: uneQualite dansSituation: uneSituation.	"création des attributs dont la cardinalite est définie et > 0"	uneEssence isIndividu ifTrue: [		uneEssence getAttributs do: [ :each |			c := each value.			(c notNil and: [ c > 0 ]) ifTrue: [				(1 to: c) do: [ :x |					n := uneEssence genSym: each key getNom.					self soitAttribut: n de: etre essence: each key] ] ] ].	"les états essentiels se situent dans la situation de définition l'être"	uneEssence getQualites do: [ :each |		(each getStatut == #essentielle and: [			 each getEffectivite == #permanente ]) ifTrue: [			etre affecteEtatEssentiel: each  ] ].	etre setDescription: 'soit: ', nom, ' essence: ', uneEssence getNom, ' situationIndividuelle: ', uneSituation getNom printString, ' quiEst: ', uneQualite getNom printString.	^ etre! !!ICEO methodsFor: 'etres' stamp: 'RB 4/15/2024 07:59'!soitAttribut: unStringOrSymbol de: unEtre essence: uneEssence	"définition d'un attribut d'un être d'essence uneEssence.	Il faudra vérifier qu'il est prévu au niveau de l'essence de self  d'avoir un attribut ayant comme essence uneEssence 	"	| nom attribut |	Smalltalk at: #sib ifPresent: [:x | x window close].		nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	unEtre getStructure 		detect: [ :each |		each getNom == nom and: [ each getEssence == uneEssence ] ]		ifFound: [ :x |			Exception new signal: 'un être nommé ''' , x getNom, ' d''essence ', uneEssence getNom, ' est déjà attribut de ', unEtre getNom ].	attribut := uneEssence new.	attribut setNom: nom.	attribut setSituationDefinition: unEtre.	attribut isSituation: false.	attribut isEtat: false.	(unEtre getStructure) add: attribut.		"les états essentiels se situent dans la situation de définition l'être"	uneEssence getQualites do: [ :each |		(each getStatut == #essentielle and: [			 each getEffectivite == #permanente ]) ifTrue: [			attribut affecteEtatEssentiel: each  ] ].	attribut setDescription: 'soitAttribut: ', nom, ' de: ', unEtre getNom, ' essence: ', uneEssence getNom.	^ attribut! !!ICEO methodsFor: 'etres' stamp: 'RB 4/2/2024 17:22'!soit: unStringOrSymbol situationGenerique: uneSituationGenerique dansSituationIndividuelle: uneSituationIndividuelle	"définition dans uneSituationIndividuelle d'une situation individuelle	instance de la situation générique uneSituation"	"exige que uneSituationIndividuelle soit instance d'une situation	générique où se situe une situationGenerique"	| nom situation |		Smalltalk at: #sib ifPresent: [:x | x window close].			(uneSituationIndividuelle getSituationGenerique includes:		 uneSituationGenerique) ifFalse: [		Exception new signal:			uneSituationGenerique , ' doit être incluse dans l''essence de '			, uneSituationIndividuelle ].	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	situation := uneSituationGenerique new.	situation setNom: nom.	situation setSituationDefinition: uneSituationIndividuelle.	situation isSituation: true.	situation setDescription: 'soit: ', nom, ' situationGenerique ', uneSituationGenerique getNom, ' situationIndividuelle: ', uneSituationIndividuelle getNom printString.! !!ICEO methodsFor: 'etres' stamp: 'RB 4/15/2024 08:52'!soit: unStringOrSymbol situationGenerique: uneSituation	"définition dans le monde d'une situation individuelle  instance de la situation générique uneSituation définie dans l'absolu"	| nom situation |	Smalltalk at: #sib ifPresent: [:x | x window close].		nom := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	situation := uneSituation new.	situation setNom: nom.	situation setSituationDefinition: (Smalltalk at: #monde).	situation isSituation: true.	(Smalltalk at: #monde) introductionEtre: situation.	situation setDescription: 'soit: ', nom printString, ' situationGenerique ', uneSituation getNom.! !!ICEO methodsFor: 'etres' stamp: 'RB 4/15/2024 10:05'!soitEtat: unStringOrSymbol essence: uneQualite situationIndividuelle: uneSituation	"définition dans uneSituationIndividuelle d'un état d'essence	uneQualite dont l'étant est indéterminé"	| nom etat essence inconnu |	Smalltalk at: #sib ifPresent: [:x | x window close].	nom := unStringOrSymbol isSymbol ifTrue: [ unStringOrSymbol ].	uneQualite isQualite ifFalse: [		Exception new signal: uneQualite , 'n''est pas une qualité' ].	etat := uneQualite new.	etat setNom: nom.	etat setSituationDefinition: uneSituation.	etat isSituation: false.	etat isEtat: true.	uneSituation introductionEtre:  etat.	"recherche de l'essence ayant cette qualité"	essence := self class getPremierGenusCommun:		           uneQualite getEssencesQualifiees.	inconnu := essence getInstance:			 'un(e) ' , essence getNom , ' inconnu(e)'.	etat setEtant: inconnu.	inconnu setSituationDefinition: (Smalltalk at: #absolu).	inconnu isSituation: false.	inconnu isEtat: false.	etat setDescription: 'soitEtat: ', nom, ' essence: ', uneQualite getNom, ' situationIndividuelle: ', uneSituation getNom printString.! !!ICEO methodsFor: 'etres' stamp: 'RB 4/15/2024 08:50'!soit: unStringOrSymbol essence: uneEssence	"définition dans le monde d'un être d'essence uneEssence"	| nom etre c n |	Smalltalk at: #sib ifPresent: [:x | x window close].	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(Smalltalk at: #monde) getElements		detect: [ :each |		each getNom == nom and: [ each getEssence == uneEssence ] ]		ifFound: [ :x |			Exception new signal: 'un être nommé ''' , x getNom				, ''' de même essence existe déjà dans le monde' ].	etre := uneEssence new.	etre setNom: nom.	etre setSituationDefinition: (Smalltalk at: #monde).	etre isSituation: false.	etre isEtat: false.	(Smalltalk at: #monde) introductionEtre: etre.	"création des attributs dont la cardinalite est définie et > 0"	uneEssence isIndividu ifTrue: [		uneEssence getAttributs do: [ :each |			c := each value.			(c notNil and: [ c > 0 ]) ifTrue: [				(1 to: c) do: [ :x |					n := uneEssence genSym: each key getNom.					self soitAttribut: n de: etre essence: each key] ] ] ].	"les états essentiels se situent dans la situation de définition l'être"	uneEssence getQualites do: [ :each |		(each getStatut == #essentielle and: [			 each getEffectivite == #permanente ]) ifTrue: [			etre affecteEtatEssentiel: each  ] ].	etre setDescription: 'soit: ', nom, ' essence: ', uneEssence getNom.	^ etre! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:31'!definitionQualiteEssentielle: unStringOrSymbol pour: uneEssence effectivite: unSymbole	"définition dans la situation de définition de uneEssence d'une manière d'être essentielle subsumée par chose "	| nom essence s col |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	s := uneEssence getSituationDefinition.	s isSituation		ifTrue: [ col := s getElements ]		ifFalse: [ col := s getEssencesAttributs ].	col detect: [ :each | each getNom == nom ] ifFound: [ :x |		Exception new signal:			'une essence nommée ''' , x getNom , ''' existe déjà dans '			, s getNom ].	essence := (Smalltalk at: #chose) createFreeSubclass: nom.	"uneEssence getDifferentia add: essence."	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneEssence.	essence isSituation: false.	essence isQualite: true.	essence setStatut: #essentielle.	essence setEffectivite: unSymbole.	uneEssence getQualitesPropres add: essence.	essence getEssencesQualifiees add: uneEssence.	essence setDescription:		'definitionQualite: ' , unStringOrSymbol printString , ' pour: '		, uneEssence getNom printString , ' effectivite: '		, unSymbole printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:30'!definitionAttribut: unStringOrSymbol de: uneEssence genus: uneAutreEssence	"définition dans le differentia de une essence d'une essence subsumée	par uneAutreEssence"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each key getNom == nom ]		ifFound: [ :x |			Exception new signal: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := uneAutreEssence createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	attribut isSituation: false.	uneEssence getDifferentia add: (Association key: attribut value: nil).	attribut setDescription:		'definitionAttribut: ' , unStringOrSymbol printString , ' de: '		, uneEssence getNom printString , ' genus: '		, uneAutreEssence printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:32'!definitionSituation: unStringOrSymbol	"définition dans absolu  d'une situation générique subsumée par Essence "	| sg nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(Smalltalk at: #absolu) getSituations		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			Exception new signal:				'une situation nommée ''' , x getNom , ''' existe déjà dans '				, #absolu ].	sg := Essence createFreeSubclass: nom.	(Smalltalk at: #absolu) getDifferentia add: sg.	(Smalltalk at: #Lexique) add: nom.	sg isSituation: true.	Smalltalk at: nom asSymbol put: sg.	sg setDescription:		'definitionSituation: ' , unStringOrSymbol printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/14/2024 23:50'!definition: unStringOrSymbol	"définition dans absolu d'une essence subsumée par chose"  	| nom essence |		nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	(Smalltalk at: #absolu) getElements		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			Exception new signal:				'une essence nommée ''' , x getNom				, ''' existe déjà dans l''absolu' ].	essence := (Smalltalk at: #chose) createFreeSubclass: nom.	(Smalltalk at: #Lexique) add: nom.	Smalltalk at: nom put: essence.	essence setSituationDefinition: (Smalltalk at: #absolu).	(Smalltalk at: #absolu) getDifferentia add: essence.	essence isSituation: false.	essence isQualite: false.	essence setDescription: 'definition: ' , unStringOrSymbol printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:31'!definitionQualite: unStringOrSymbol situation: uneSituation genus: uneEssence	"définition dans uneSituation d'une manière d'être subsumée par uneEssence "	| nom essence |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneSituation getElements		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			Exception new signal:				'une essence nommée ''' , x getNom , ''' existe déjà dans '				, uneSituation getNom ].	essence := uneEssence createFreeSubclass: nom.	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneSituation.	uneSituation getDifferentia add: essence.	essence isSituation: false.	essence isQualite: true.	essence setStatut: #accidentelle.	essence setEffectivite: #intermittente.	essence setDescription:		'definitionQualite: ' , unStringOrSymbol printString		, ' situation: ' , uneSituation getNom printString , ' genus: '		, uneEssence getNom printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:32'!definitionSituation: unStringOrSymbol dans: uneSituationGenerique	"définition dans uneSituationGenerique d'une situation générique subsumée par Essence "	| sg nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(Smalltalk at: #absolu) getSituations		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			Exception new signal:				'une situation nommée ''' , x getNom , ''' existe déjà dans '				, #absolu ].	sg := Essence createFreeSubclass: nom.	uneSituationGenerique getDifferentia add: sg.	(Smalltalk at: #Lexique) add: nom.	sg isSituation: true.	Smalltalk at: nom asSymbol put: sg.	sg setDescription:		'definitionSituation: ' , unStringOrSymbol printString , ' dans: '		, uneSituationGenerique getNom printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/14/2024 23:51'!definition: unStringOrSymbol genus: uneEssence metaEssence: uneAutreEssence	"définition dans l'absolu d'une essence subsumée par uneEssence et instance de uneAutreEssence"	| nom essence |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	(Smalltalk at: #absolu) getElements		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			Exception new signal:				'une essence nommée ''' , x getNom				, ''' existe déjà dans l''absolu' ].	essence := uneEssence createFreeSubclass: nom.	essence setMetaEssence: uneAutreEssence.	(Smalltalk at: #Lexique) add: nom.	Smalltalk at: nom put: essence.	essence setSituationDefinition: (Smalltalk at: #absolu).	(Smalltalk at: #absolu) getDifferentia add: essence.	essence isSituation: false.	essence isQualite: false.	essence setDescription:		'definition: ' , unStringOrSymbol printString , ' genus: '		, uneEssence getNom printString , ' métEssence '		, uneAutreEssence getNom printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ]! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:31'!definitionAttribut: unStringOrSymbol de: uneEssence isPrototype: aBoolean cardinalite: uneValeur	"définition dans le differentia de une essence d'une essence subsumée par chose qui est prototype"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each key getNom == nom ]		ifFound: [ :x |			Exception new signal: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := (Smalltalk at: #chose) createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	uneEssence getDifferentia add:		(Association key: attribut value: uneValeur).	attribut isSituation: false.	attribut isPrototype: aBoolean.	attribut setDescription:		'definitionAttribut: ' , unStringOrSymbol printString , ' de: '		, uneEssence getNom printString , ' isProtype: '		, aBoolean printString , ' cardinalité: ' , uneValeur printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/14/2024 17:16'!definition: unStringOrSymbol genus: uneEssence 	"définition dans absolu  d'une essence subsumée par uneEssence"	| nom essence | 	[nom := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	(nom at: 1) isLowercase ifFalse: [Exception new signal: 'le nom commun d''une essence doit commencer par une minuscule'].	(Smalltalk at: #absolu)  getElements		detect: [:each | each getNom == nom]		ifFound: [:x | Exception new signal: 'une essence nommée ''' , x getNom, ''' existe déjà dans l''absolu'].	essence := uneEssence createFreeSubclass: nom.	(Smalltalk at: #Lexique)		add: nom.	Smalltalk		at: nom		put: essence.	essence setSituationDefinition: (Smalltalk at: #absolu).	(Smalltalk at: #absolu) getDifferentia add: essence.	essence isSituation: false.	essence isQualite: false.	essence setDescription: 'definition: ', unStringOrSymbol printString, ' genus: ', uneEssence getNom printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]]		on: Exception		do: [ :ex |			SpInformDialog new			title: '';				extent: 600@120;				label: ex description;				acceptLabel: 'OK';				openDialog ]! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:29'!definitionAttribut: unStringOrSymbol de: uneEssence	"définition dans le differentia de une essence d'une essence subsumée par chose"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each key getNom == nom ]		ifFound: [ :x |			Exception new signal: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := (Smalltalk at: #chose) createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	uneEssence getDifferentia add: (Association key: attribut value: nil).	attribut isSituation: false.	attribut setDescription:		'definitionAttribut: ' , unStringOrSymbol printString , ' de: '		, uneEssence getNom printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:31'!definitionQualiteEssentielle: unStringOrSymbol genus: uneEssence pour: uneAutreEssence effectivite: unSymbole	"définition dans la situation de définition de uneEssence d'une manière d'être essentielle subsumée par chose "	| nom essence s col |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	s := uneAutreEssence getSituationDefinition.	s isSituation		ifTrue: [ col := s getElements ]		ifFalse: [ col := s getEssencesAttributs ].	col detect: [ :each | each getNom == nom ] ifFound: [ :x |		Exception new signal:			'une essence nommée ''' , x getNom , ''' existe déjà dans '			, s getNom ].	essence := uneEssence createFreeSubclass: nom.	uneAutreEssence getDifferentia add: essence.	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneAutreEssence.	essence isSituation: false.	essence isQualite: true.	essence setStatut: #essentielle.	essence setEffectivite: unSymbole.	uneAutreEssence getQualitesPropres add: essence.	essence getEssencesQualifiees add: uneAutreEssence.	essence setDescription:		'definitionQualite: ' , unStringOrSymbol printString , ' genus: '		, uneEssence getNom printString , ' pour: '		, uneAutreEssence getNom printString , ' effectivite: '		, unSymbole printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:30'!definitionAttribut: unStringOrSymbol de: uneEssence isPrototype: aBoolean	"définition dans le differentia de une essence d'une essence subsumée par chose"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each key getNom == nom ]		ifFound: [ :x |			Exception new signal: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := (Smalltalk at: #chose) createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	uneEssence getDifferentia add: (Association key: attribut value: nil).	attribut isSituation: false.	attribut isPrototype: aBoolean.	attribut setDescription:		'definitionAttribut: ' , unStringOrSymbol printString , ' de: '		, uneEssence getNom printString , ' isPrototype '		, aBoolean printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ]! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:30'!definitionAttribut: unStringOrSymbol de: uneEssence genus: uneAutreEssence cardinalite: uneValeur	"définition dans le differentia de une essence d'une essence subsumée	par uneAutreEssence"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each key getNom == nom ]		ifFound: [ :x |			Exception new signal: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := uneAutreEssence createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	attribut isSituation: false.	uneEssence getDifferentia add:		(Association key: attribut value: uneValeur).	attribut isSituation: false.	attribut setDescription:		'definitionAttribut: ' , unStringOrSymbol printString , ' de: '		, uneEssence getNom printString , ' genus: '		, uneAutreEssence printString , ' cardinalité: '		, uneValeur printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:31'!definitionQualite: unStringOrSymbol situation: uneSituation	"définition dans uneSituation d'une manière d'être subsumée par chose "	| nom essence |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneSituation getElements		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			Exception new signal:				'une essence nommée ''' , x getNom , ''' existe déjà dans '				, uneSituation getNom ].	essence := (Smalltalk at: #chose) createFreeSubclass: nom.	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneSituation.	uneSituation getDifferentia add: essence.	essence isSituation: false.	essence isQualite: true.	essence setStatut: #accidentelle.	essence setEffectivite: #intermittente.	essence setDescription:		'definitionQualite: ' , unStringOrSymbol printString		, ' situation: ' , uneSituation getNom printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ]! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:30'!definitionAttribut: unStringOrSymbol de: uneEssence cardinalite: uneValeur	"définition dans le differentia de une essence d'une essence subsumée par chose"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each key getNom == nom ]		ifFound: [ :x |			Exception new signal: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := (Smalltalk at: #chose) createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	uneEssence getDifferentia add:		(Association key: attribut value: uneValeur).	attribut isSituation: false.	attribut setDescription:		'definitionAttribut: ' , unStringOrSymbol printString , ' de: '		, uneEssence getNom printString , ' cardinalité: '		, uneValeur printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:29'!definition: unStringOrSymbol situation: uneSituation	"définition dans uneSituation d'une essence subsumée par chose"	| nom essence |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneSituation getElements		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			Exception new signal: 'une essence nommée ''' , x getNom, ''' existe déjà dans '				, uneSituation getNom ].	essence := (Smalltalk at: #chose) createFreeSubclass: nom.	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneSituation.	uneSituation getDifferentia add: essence.	essence isSituation: false.	essence isQualite: false.	essence setDescription: 'definition: ', unStringOrSymbol printString, ' situation: ', uneSituation getNom printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 4/15/2024 08:29'!definition: unStringOrSymbol situation: uneSituation genus: uneEssence	"définition dans uneSituation d'une essence subsumée par uneEssence"	| nom essence |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		Exception new signal:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneSituation getElements		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			Exception new signal:				'une essence nommée ''' , x getNom , ''' existe déjà dans '				, uneSituation getNom ].	essence := uneEssence createFreeSubclass: nom.	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneSituation.	uneSituation getDifferentia add: essence.	essence isSituation: false.	essence isQualite: false.	essence setDescription:		'definition: ' , unStringOrSymbol printString , ' situation: '		, uneSituation getNom printString , ' genus: '		, uneEssence getNom printString.	Smalltalk at: #sgb ifPresent: [ :x | x window close ] ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICEO class	instanceVariableNames: ''!!ICEO class methodsFor: 'intialise' stamp: 'RB 3/27/2024 19:31'!reset	| abs th wd |	(Smalltalk at: #Lexique) do: [:each | Smalltalk globals removeKey: each ifAbsent: []].	Smalltalk at: #iceo put: self new.	Smalltalk at: #Lexique put: OrderedCollection new.	Smalltalk at: #GenSym put: Dictionary new.	Essence subclasses		do: [:each | Essence removeSubclass: each].	abs := Essence createFreeSubclass: #absolu.	Smalltalk at: #absolu put: abs.	(Smalltalk at: #absolu) setDescription: 'absolu est la racine des situations génériques'.	abs isSituation: true.	abs isQualite: false.	th := Essence createFreeSubclass: #chose.	Smalltalk at: #chose put: th.	(Smalltalk at: #chose) setDescription: 'chose est l''essence racine de la hiérarchie des essences'.	(Smalltalk at: #Lexique) add: #chose.	(Smalltalk at: #absolu) getDifferentia add: (Smalltalk at: #chose).	th isSituation: false.	th isQualite: false.	th setSituationDefinition: abs.	wd := abs new.	wd setNom: #monde.	Smalltalk at: #monde put: wd.	(Smalltalk at: #Lexique) add: #monde.	wd isSituation: true.	wd isEtat: false.	Smalltalk at: #sgb ifPresent: [:x | x window close].	Smalltalk at: #sib ifPresent: [:x | x window close]! !!ICEO class methodsFor: 'private' stamp: 'RB 4/14/2024 20:14'!start	| abs th wd |	"Appelée lors du chargement de ICEO.st"	ShiftClassBuilder compile: 'validateClassName	name ifNil: [ ^self ].	"I try to convert to symbol, if there is an error the next guard will catch it"	[ name := name asSymbol ] on: Error do: [  ].	name isSymbol ifFalse:[InvalidGlobalName				signal: ''Global names should be symbols''				for: name]."	name isValidGlobalName ifFalse: [		InvalidGlobalName signal: ''Class name is not a valid global name. It must start with uppercase letter and continue with alphanumeric characters or underscore. Default names used in class or trait templates are not allowed.'' for: name ]."	DangerousClassNotifier check: name'.	ICEO forDoIt.	ICEO forDoItInPlayground.	ICEO buildIcons.	[	(Smalltalk globals hasClassNamed: 'absolu') ifTrue: [		Exception new signal:			'ICEO start ne peut être utilisée qu''une seule fois. 		Utiliser ICEO reset' ].	Smalltalk at: #iceo put: self new.	Smalltalk at: #Lexique put: OrderedCollection new.	Smalltalk at: #GenSym put: Dictionary new.	abs := Essence createFreeSubclass: #absolu.	Smalltalk at: #absolu put: abs.	(Smalltalk at: #absolu) setDescription:		'absolu est la racine des situations génériques'.	abs isSituation: true.	abs isQualite: false.	th := Essence createFreeSubclass: #chose.	Smalltalk at: #chose put: th.	(Smalltalk at: #Lexique) add: #chose.	(Smalltalk at: #chose) setDescription:		'chose est l''essence racine de la hiérarchie des essences'.	th isSituation: false.	th isQualite: false.	th setSituationDefinition: abs.	wd := abs new.	wd setNom: #monde.	Smalltalk at: #monde put: wd.	(Smalltalk at: #Lexique) add: #monde.	wd isSituation: true.	wd isEtat: false.	Transcript		cr;		show: 'ICEO initialisé avec absolu, monde et chose' ]		on: Exception		do: [ :ex |			SpInformDialog new				title: '';				extent: 600 @ 120;				label: ex description;				acceptLabel: 'OK';				openDialog ]! !!ICEO class methodsFor: 'worldMenu' stamp: 'RobertBourgeois 3/25/2024 12:22'!ajoute: aBuilder	<worldMenu>	(aBuilder item: #ICEO)		order: 5! !!ICEO class methodsFor: 'worldMenu' stamp: 'RB 4/9/2024 17:21'!addSiBrowser: aBuilder	<worldMenu>	| sibr |	(aBuilder item: #SiBrowser)		parent: #ICEO;		order: 3;		help: 'Open a SiBrowser';		iconName: #glamorousInspect;		label: 'SiBrowser';		action: [			Smalltalk at: #sib ifPresent: [ :x | x window close ].			sibr := SiBrowser new.			Smalltalk at: #sib put: sibr.			sibr open ]! !!ICEO class methodsFor: 'worldMenu' stamp: 'RB 4/9/2024 17:21'!addSgBrowser: aBuilder	<worldMenu>	| sgbr |	(aBuilder item: #SgBrowser)		parent: #ICEO;		order: 2;		help: 'Open a SgBrowser';		iconName: #glamorousInspect;		label: 'SgBrowser';		action: [			Smalltalk at: #sgb ifPresent: [ :x | x window close ].			sgbr := SgBrowser new.			Smalltalk at: #sgb put: sgbr.			sgbr open ]! !!ICEO class methodsFor: 'worldMenu' stamp: 'RB 4/9/2024 17:21'!addReset: aBuilder<worldMenu>			(aBuilder item: #Reset)				parent: #ICEO;				order: 1;				help: 'Reset ICEO';				iconName: #glamorousTrash;				label: 'ICEO reset';				action: [ ICEO reset ];				withSeparatorAfter ! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:01'!lightBlueTriangleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAOCAYAAAAmL5yKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAEZSURBVDhPY8AL5r31AmM8gBFKY4KZ/1kZWN9dArN/C+kxpDP+BrPRABOUxgRs7zMZGBk1wBjExgGwu2DhR2GGf39uAaWFIAL/3zEwfVdjiJd5C+EjAHYX/P1Tj9AMAkD2X06gGCbAdMHCT5pA2y8CWawQATj4zcDEos8Qz3cdygcDTBf8+9MLJNE1gwAr0GUgORSAasDct55AEoSxA0agHEQNHCAMmHmGFagAwwYMwMTYA1YLBQgD2BQygFGmCeXhA1oM7ErpUDY0EGd/EGJg/nsLaIAwmE8I/P//luEvsxpDqsA7iAuY/9YTrRkEQGpZ/teBmQzzX2sAfQJMsozYQh4P+A9M2v/0GBnmvVsONAZvhsEJ/jNsAwANvUW1sWq69AAAAABJRU5ErkJggg=='! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 23:05'!orangeTriangleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAOCAYAAAAmL5yKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAEXSURBVDhPjZNdTgJBDMf/XbMb4ouEvQNhNdFzwD0I+MAV9ALwxNPKAbyBp/BFX0y4AwQTIYTNOrSlWXVn3PBLJtOPaadpZ9DEfoGBLFODkO0eLke8I7yLfOlwSyMU6qgR2e6xi3DP2XuyRDazR7CCzznSOMGSvR01OKyLA7pXE6xU/0WwAg5+rIIFltUWwKuAm5aVDm/siM2kOKC4INy1hvgwk+JV8O0wqwcLYuPEM1Mr/iT4ytHnTVYQTtK3MxVVglceGx/wbqgTEaZy1tSfBBlhTITM1CaubyKMTD41cbNAJ3E8NiAV/QxWB0K3PcRaK0hKHdG5wULKFz6IQPscvZKfbKjzTehY5Ylvn/DMwY0f5j8c8HIE2CtCARfgnkYAAAAASUVORK5CYII='! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:03'!yellowTriangleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAOCAYAAAAmL5yKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAEjSURBVDhPjZOxTgJBEIbnX9hWCVSosSRggc+BD4JaWmiw0dYYjb0v4Bv4FDbSmFgaRRtIrE9unBlHFPY4/ZK9nf+f2b252yyVkY8Od3S4LAQ+JzD3I7+uDjVG870LXGeWWCD4nMBvtX0AbR0au51Q2EH+PGhQJX+UZF01E01oGlph42xsBb8o7iDkp9+LFYvFczlH0kE+OuqIey+J6JYhXWTy2A5r5w9uGWkH4MvFxYp5knM5Y24DeXsPhJ7LBM1pjUtjtgHf9aOcXfKGBNCF1To/GzRX9hDQcbkU+ZQtXq/tulQtrT8d1ClW5djQMPcPmHhM2UcrbF5NvjqoVuXY/rdYsdoYTyzml+M2YzoE0j9fBjNl4EoXclluCCi9MEthvv0EZc1VUJPb4QUAAAAASUVORK5CYII='! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:00'!blueCircleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJxSURBVDhPXZK/S1ZhFMfPc54fr1mLEBE56JZI0RA0NeUg2F/QFBE61BQNUYtLS0hDCgU6tukSLRGkYNDW+JI0KTRkhlaKb++9z6++57lXhR4499z3vs/nc84991H037oz93HcE81UmSeSsqPEWmW2W0qbNW3U4vK98W67taxjwexy133b3J3rJ3W/T1pHdqSMIzYWDoNgUkol0vzq3PDIw4UproQrgtnZrvs+uPf2oKbJw8jkdYfYdUgbQ9oijCaD0FqTYiA5rw6dH74pEhbB7pm9Z72/eXK/R9SrDPloKUKUMlMmVGZdujCQWWvJOjvx5+f2c2HV4/lPY78PQ/fHPul9rymguh5wZByADgBkh+yQLQSqfemEFTJdYeTpfk26wuRikoYQWboslxJyL7flj3ZhHpxCnOGc6EYNVYhiVQ2TACBSRLQ5xkQhpGNZxLMc0w3Go5FUYAFbGJuzwMgRUIQ9+Ei+DlRXTci993G0DBEIDI2ACtjASWCAAocWrorAl/tQx8x4ly2NwaD5UlngUt0L3ApqVJeqAvcBIzwkeL6Jr5rXLAw4b6TQQsY8MipL9QS4CEq1RuD7Imkyfq8yvvPSgFOhYzJpioAjQEhQvXRRQYIOArKISuXSSYixSos89+D6V83qxSmnyOlEnEPTASQiOJIEVDwKj1eIdVj48PTyRhniTrX9xGR+N2gg4Ugq+gauT0K6EFHqIQ7C+50B90hYLZcv6yvx4oWpFeOGTqvI18oZLsPEdBEcsNErMn0Vraf5s78G766/vFQL2x7Mk3Xr9ucxHItpHKCJlNVo2ZJpi1itYcRLb15f3Wi3YhH9A+Ds0kqzi+vxAAAAAElFTkSuQmCC'! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:00'!greenTriangleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAOCAYAAAAmL5yKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAEuSURBVDhPlZHPSsNAEMZntgm9pyf/QNBDaT3UShB8hYqvUaoHX8E+QU8FpfSFBCnSHhR6E8Rbcg/Z7HRnnQbbxFp/MMzMl5nNlyzsIno6veaQthKUXCKaRL4xyYJrpYLObDDL3IMtlOQSRPEdIrQ4uBa5RKWDy/FhQ3v1pV0OuCeCxNNp8+X+K3YDP6h0kHv14XqZ4Zo1aTcoObiYhm3QOEdEXyQHEWXg0flr/+NdJEfJAeZqtL3MsIZajaQt2Dig+xj2bOKoBqEnMwXFJ/C1kUnmVmmL9BtviEF3fa2FA0Px7R7LzJmBZCD1t4Or6XGQ5v7SNg2n/gEBxPVa1nzufybOQar94b7LDM/aFz64OpqELWNwUfXnd8HXqhR1agc3wdgeeWK19F+BoAHU0Qqv1WXk5FrHhQAAAABJRU5ErkJggg=='! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:01'!orangeCircleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJbSURBVDhPXVNNaxRBEK3q+eg1SMCjp+jRU/wJkuTir5CAkoAuKCLiRTFHwYAggtlc9uJJb96Ci/9AQcFj4kVy0uCuuzP9Vb7qcddos297prvee1XVPUz/jcnO1moZp1uS2nWmcJFNIlPSkSn5XSCzZx+8+fAnNI+FwOGja73z9dmnsZlss58aQx5EkGsmrg1xaUgKFjAGHOm2uft6prwskJ71rXPV2zg+2ZDZTzLSUlkLGQuyBbkuiKqCGCDDJCLvubZXeXPYGBXwtPwkuemG+DEZmlFp4d6LICcApjWcIES2JOpVxL36iojfVS43g51LNJl8ij+OC2pOqGBHRSYxMoCrutdVh0qVuqolpUQxXjYVFdfFNYX4lrCAHdEfZgX+Ts+nBjOjKXLDpJjWxDuSGNCM1AVi0ln0NeEhA+Iak8UANQtxDR2SFaSDBd1QMpqkRLx3SCQBwR5wHnAdPJ5jWEEandtfRyUDahaw6BUQ8VhwQAtyq0KBxEU0nfhrLkcfF+6YVQDkBLJCg6UFKcN3s4tHKMGMGN1lU6A0EOFOOQM8w0hFxEGghVCrInOoUByZGOI+1zj0ypLgzs7dk8IzJWScWmQCZJEmAonCDOcYwsD0bj78wmX53NglwvXDARg0vMskl+H+FemAOp28sI8PPuebWNH4Pok94GqJREW0FC1BBXIvVARomeLUUBiXo2/HzT3lLj6m1O/bXxR3o59uaxTje0D4/OJhoEexSiJmbzmducPDYaOri+35+L55axUnscWS1pHKBdwZaMghtkYs4eW5V/sfu0gdRL8BRL6aunCOC8oAAAAASUVORK5CYII='! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:02'!purpleCircleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAGYSURBVDhPnVO/S8JBFH/3Tr+aolHOgaNDa5BTpBBuTblH6FZDi0GTRIMQDTaVQ1OLTm0iGDj5D0Q0OjQUWVH+/vq9e919k7LS0D7wgeNz7/Pu3rt7DH4gu3YeMsCddJErggyDWpMkayYzyz3o5HZKm7d24ACfCfIbeePp2czMMN+2i7n4QP6GHvVEhxongXkjFS/ETa3ZCbS5/tK/9IE/xgC1NBYEEhryrfgQcK6nVRI7+r7eznjIGyNS2yT+pI7xMG8soDzay45WTkM+9F8bzD3y2uNgUleomywiYyzJwcGFyj4NtQcRE8jJEfkQrSkpACWPoqopOKrWSai9qBdC/o/aixb1a8O1TcO+8qLq5tWozUloUq+MlqSzjuwKS0qYhtojZCfHK3elenhhdY6TsUzqfeUEVO2DNmtlD6p7F/ZPdLw2Uy1qFvuqMaNOG6aO0bHao73276s8VkRkNlxoOYWPgC0BIP4+mcAEU3SxmXU32lvpm/TXMA1jN3wYIoEJLh1RNVj2OKsJqQm0yozL3HF1f2icAd4BfoMJKR+SVQUAAAAASUVORK5CYII='! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:02'!redTriangleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAOCAYAAAAmL5yKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAEhSURBVDhPjZPBUsJADIY3rRW9wqFZhjMDjOLFl8AXUV8CX0CfgzfwKbyAqDOeGaYe4O5027hZItruUv1mtps/m6SZTauaeEG84iUyCMju8aRU0kpxwfbnRza+VCp3BzUi2T1OU30LAANebIvbI9jBa7fbKYry3Sa3WRPRNo6j/mi93riAXwQ7KMry7juZYZt9Iit4HTwjDkHB3JrJzrMnJ0UX51n2Jtrhd0DwYJ/1ZCaRswqVAnPECYCaiPTgM44R6dgX4LHFgTfUiQjuOVbkT4HjVN/YGxmKPIjtYnSS6muRu0tc9nptyg2PreO8f2DHuoHkqH+2Wm1dB2QMj+1fyYyLNWbq7IXWg4jIfrIQuvkGKC8BxrBEnNnkxh/mMPT4BRwwTvcqkjF8AAAAAElFTkSuQmCC'! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/15/2024 09:59'!forDoIt	"Permet que les lignes évaluées en bloc soient évaluées en séquence et attrape les exceptions"	RubSmalltalkEditor		compile: 'evaluateSelection	| node aString |	node := RBParser parseExpression: self selectionAsStream contents.	node class == RBMessageNode ifTrue: [		[ OpalCompiler new evaluate: node newSource ]			on: Exception			do: [ :ex |				SpInformDialog new					title: '''';					extent: 600 @ 120;					label: ex description;					acceptLabel: ''OK'';					openDialog. Transcript clear; show: node newSource ]].	node class == RBSequenceNode ifTrue: [		[		node statements do: [ :each | aString := each newSource.			Semaphore new				wait: (Duration milliSeconds: 10)				onCompletion: [  ]				onTimeout: [ OpalCompiler new evaluate: each newSource ] ] ]			on: Exception			do: [ :ex |				SpInformDialog new					title: '''';					extent: 600 @ 120;					label: ex description;					acceptLabel: ''OK'';					openDialog. Transcript clear; show: aString ]]'		classified: 'do-it'! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/15/2024 10:02'!forDoItInPlayground	"Permet que les lignes évaluées en bloc soient évaluées en séquence et attrape les exceptions"	SpCodePresenter		compile: 'evaluate: aString onCompileError: compileErrorBlock onError: errorBlock	| receiver result oldBindings node aLine |	node := RBParser parseExpression: aString.	node class == RBMessageNode ifTrue: [		[		^ [		  self announcer announce:			  (SpCodeWillBeEvaluatedAnnouncement newContent: aString).		  oldBindings := self interactionModel bindings copy.		  receiver := self interactionModel doItReceiver.		  result := receiver class compiler			            source: aString;			            context: self interactionModel doItContext;			            receiver: self interactionModel doItReceiver;			            requestor: self interactionModel;			            environment: self environment;			            failBlock: [				            self announcer announce:						            (SpCodeEvaluationFailedAnnouncement newContent:								             aString).				            ^ compileErrorBlock value ];			            evaluate.		  oldBindings size = self interactionModel bindings size ifFalse: [			  self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].		  self announcer announce:			  (SpCodeEvaluationSucceedAnnouncement newContent: aString).		  result ]			  on: Error			  do: [ :e |				  self announcer announce:					  (SpCodeEvaluationFailedAnnouncement						   newContent: aString						   error: e).				  errorBlock value: e ] ]			on: Exception			do: [ :ex |				SpInformDialog new					title: '''';					extent: 600 @ 120;					label: ex description;					acceptLabel: ''OK'';					openDialog. Transcript clear; show:  aString] ].										node class == RBSequenceNode ifTrue: [		[		node statements do: [ :each | aLine := each newSource.			Semaphore new				wait: (Duration milliSeconds: 10)				onCompletion: [  ]				onTimeout: [					self announcer announce:						(SpCodeWillBeEvaluatedAnnouncement newContent: each newSource).					oldBindings := self interactionModel bindings copy.					receiver := self interactionModel doItReceiver.					result := receiver class compiler						          source: each newSource;						          context: self interactionModel doItContext;						          receiver: self interactionModel doItReceiver;						          requestor: self interactionModel;						          environment: self environment;						          failBlock: [							          self announcer announce:									          (SpCodeEvaluationFailedAnnouncement newContent:											           each newSource).							          ^ compileErrorBlock value ];						          evaluate.					oldBindings size = self interactionModel bindings size ifFalse: [						self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].					self announcer announce:						(SpCodeEvaluationSucceedAnnouncement newContent: each newSource).					result ] ] ]			on: Exception			do: [ :ex |				SpInformDialog new					title: '''';					extent: 600 @ 120;					label: ex description;					acceptLabel: ''OK'';					openDialog. Transcript clear; show:  aLine ] ]'		classified: 'command support'.! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/3/2024 09:48'!buildIcons"		ICEO buildIcons   "	" ThemeIcons compile:  'yellowCircleIconContents	^ ''' , (Base64MimeConverter mimeEncode: 'yellowCircleIcon.png' asFileReference binaryReadStream) contents , '''' classified: 'Material-Design-Lite-Core'."	ThemeIcons		compile: 'blueCircleIcon	icons			at: #''blueCircleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO blueCircleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'redCircleIcon	^ icons			at: #''redCircleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO redCircleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'greenCircleIcon	^ icons			at: #''greenCircleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO greenCircleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'yellowCircleIcon	icons			at: #''yellowCircleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO yellowCircleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'lightBlueCircleIcon	icons			at: #''lightBlueCircleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO lightBlueCircleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'purpleCircleIcon	icons			at: #''purpleCircleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO purpleCircleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'orangeCircleIcon	icons			at: #''orangeCircleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO orangeCircleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	"-------------------------------------------------"	ThemeIcons		compile: 'blueTriangleIcon	icons			at: #''blueTriangleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO blueTriangleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'redTriangleIcon	^ icons			at: #''redTriangleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO redTriangleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'greenTriangleIcon	^ icons			at: #''greenTriangleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO greenTriangleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'yellowTriangleIcon	icons			at: #''yellowTriangleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO yellowTriangleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'lightBlueTriangleIcon	icons			at: #''lightBlueTriangleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO lightBlueTriangleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'purpleTriangleIcon	icons			at: #''purpleTriangleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO purpleTriangleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	ThemeIcons		compile: 'orangeTriangleIcon	icons			at: #''orangeTriangleIcon''			ifAbsentPut:[ Form fromBinaryStream: ICEO orangeTriangleIconContents base64Decoded asByteArray readStream ]'		classified: 'Material-Design-Lite-Core'.	Smalltalk ui icons blueCircleIcon.	Smalltalk ui icons greenCircleIcon.	Smalltalk ui icons lightBlueCircleIcon.	Smalltalk ui icons orangeCircleIcon.	Smalltalk ui icons purpleCircleIcon.	Smalltalk ui icons redCircleIcon.	Smalltalk ui icons yellowCircleIcon.	Smalltalk ui icons blueTriangleIcon.	Smalltalk ui icons greenTriangleIcon.	Smalltalk ui icons lightBlueTriangleIcon.	Smalltalk ui icons orangeTriangleIcon.	Smalltalk ui icons purpleTriangleIcon.	Smalltalk ui icons redTriangleIcon.	Smalltalk ui icons yellowTriangleIcon	! !!ICEO class methodsFor: 'utile' stamp: 'RB 3/3/2024 07:55'!getPremierGenusCommun: uneCollectionEssences 	"il faudra étendre cette méthode à un nombre d'essences > 2 !! "	| c t1 t2 |	c := uneCollectionEssences.	c size == 1		ifTrue: [^ c at: 1].	t1 := (c at: 1) getAllGenus.	t2 := (c at: 2) getAllGenus.	t1		detect: [:each | t2 includes: each]		ifFound: [:x | ^ x].   "il y a au moins l'essence chose !! "! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:02'!redCircleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAKRSURBVDhPXVI9axVBFL3ztbsvERvB0ijYWEXwD5gPUP+AlZBGSQoDWqiNjWAlGBFENLFJrWBjERCfprHzAxSENMYiIIgS49v3dmbuzHhmX14i3uXszM7ec+6ZOyPov3h//vKk9mFeuTCjOR4zkUgLsVlK9QrJy4fXHn3YTW1jT+D13Fx1KBy4S323YPpOlhypJEmFUqSVJolRSJmklCu/lL5y5Nm9Qea1AhuLi2Vdixfid29W9wbUcYE6QpIB0WhNyhSk9BBCKkqU3hTl+DmxequRWeBPLO/E/mA29WqSTUM6MIkUUD+SRAklJciGdFGRqTpkyrHTzHYpc8W76zdP0HbvU/z+U+mdmjqM6iAUqF4YQ8aUIIJUjZEux8EY7joGjszupNQpXoyNVcl5Eti3SEQpIz8YMbSvhI+MUQg0RKZ0SaaYppNjIh8gG9v8/I5IjikCAdUymCI7SjknrwdPgd00RMREQsLwB8gtQMYkYC3gX8jJ3hK7AbGtiZs+BTvAmpuQrdVcdUQEAuaMKpnMqMzsiSHgQfIg+6Ymn8Wwlk/hG6FpCe3OIgECnIEPDwceIh4CzjmQGnIQcSA7i7m3m1II0RVGU1KSGA0OrfXsYF/AMQMORLuP7Mj7rowsn4hOGXBmFLNItg+RoYNEFmoOR5tFLJxYCFnvqPEu9qNfkafu3/4ilH4gxiqKpSGPrYy2sCcCJxZOLIQshJrWUXh4fP355/Ym/jDuRtLmJXUqCoUmj61k4r9wQAOhPjpch9TdMtvXMnd4rRAbZxfLLbWzlBq7IKyTCndDwUmugD61NzCQQHfEsqsOXp1aX20yb09gFGtTFyZl4Hl0cga38iguSKZ/BbosxOMzb59+3E1FEP0FL/HRbnuU71EAAAAASUVORK5CYII='! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:02'!purpleTriangleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAOCAYAAAAmL5yKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAE0SURBVDhPlZK/TsMwEMZ9toK6tEjtyARD1TIUJB4A8UdIRX2NKDD0FcgTMDFFHqq+BoJHYCgDSH2HdoChIq5jfO4Rkdpq4SddfPedL/oSm21CnslrDCqDAK0e2UkW8QZ/xbz4KHrJS6JcYw1Oqwev81tg0MHAnGSPoIPxxbiltJrabtMJhs0XYtEePg9nrv5F0EGu87QcRmxe07WUqgqeA3kpu6BhYtNopZQoI8xR/BS/U+3wHSzZvX2uDyMR9SpUXpCdZ30A6FPpgT3cQ6Wj/AQ8NlEXE6t0SQpj2Jv+1Mc/x1o6gAbcbB1GgB3yXZ5QtXIgr2ST5WxqLbacugVjzIztsHb8GM+dA6NM+tdhxO1V7M7lo9NRR3ONVzb05zehRCF6YnAweLDXdd8KX/+MZQHF3jf09F9pbLXY5gAAAABJRU5ErkJggg=='! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:01'!orangeTriangleIconnContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAOCAYAAAAmL5yKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAEXSURBVDhPjZNdTgJBDMf/XbMb4ouEvQNhNdFzwD0I+MAV9ALwxNPKAbyBp/BFX0y4AwQTIYTNOrSlWXVn3PBLJtOPaadpZ9DEfoGBLFODkO0eLke8I7yLfOlwSyMU6qgR2e6xi3DP2XuyRDazR7CCzznSOMGSvR01OKyLA7pXE6xU/0WwAg5+rIIFltUWwKuAm5aVDm/siM2kOKC4INy1hvgwk+JV8O0wqwcLYuPEM1Mr/iT4ytHnTVYQTtK3MxVVglceGx/wbqgTEaZy1tSfBBlhTITM1CaubyKMTD41cbNAJ3E8NiAV/QxWB0K3PcRaK0hKHdG5wULKFz6IQPscvZKfbKjzTehY5Ylvn/DMwY0f5j8c8HIE2CtCARfgnkYAAAAASUVORK5CYII='! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 23:03'!yellowCircleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAIpSURBVDhPXVI9a1RREJ2ZfbvZ1Q1BsIoSIohiECF/QDEBSWFpZ2HjFzaC/gJrBUVBTOE/sIrYmRT2VtGAIqyCWGn8iPuR3X0znnPfe2vIwHlz731zzszcuSr7zDsri6JxU8SWRbN5sZaItr7Ar6s0VnX28dsyNNlEIDpXmlH7/kjy4XVVnJNo08BBRB2An5KQeohlz3UYt/XIvR55SSA650CeeaXeXRIZMyMIM0C7EDAIpLMmfCYR8UZ6umJzd/uWBLLD99X7SxIDbAJBdaCWgov1FMgUoFhb1KbPSrvxkFz1b5cXZLSzqf7TJJAdpf7PzhZK1LgHyq4jcpfhYNHE5arKsCCjy8Ic4HofWF1puCaTul+DgKP0EY5yoAwKrBMgmoD/PsT/XawpTmDvo/MmFnMFucoKnwSBQFCQxLsB8i78X4QQGEL05lE6ecxKAQoRzEhiRe5jD7Lv4PefElz3AlPQz2wnGUUmpVdEZKrICSAnYB3dDpkbIhwXb5fZq76R3SEQJFdl76mgENlQ/3rppIy779W3a+gJAiwKs5fqHTQAjDZ57HkOixjnkuVnzI6++IAbfZIeDsnVrU88Wtnbv/+G3wZ+PLXZta3iKb9baESr+VJlfCERaUmQGVkRw4hixBGj1+KDi3bi027xrGD+8Tjq9AcIuKVmZOGUbcBzUhgviPj4M7R0h2SeTgQq861Dp/HAb4C1DMaxMjEmJesQXLVTvzaLSJrIP67jKV40zUb7AAAAAElFTkSuQmCC'! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:01'!lightBlueCircleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAEbSURBVDhPpZMxTkJBEIb/GeQUNlKoibU3oEQjNp4ADmBprKUl1HAGQmJMbOAEthRqoYV6B1F2/Gd3E4MGZPFL3mbmf/vP2528EfzkOuxijhYgdYjtRM3kmcsYFQxwrI9Ry3wXuLMqXu0KhnOIbGV1EbNPOrrYlkscyodLqYCb32zILx3F/E/shkVOvYjG/MU665sdafC0nRhhGPagmC499jL8OhUcKJdWsdlxT0Bb2bR6lsqh13tQS9lG1FIT/4GyjU85LodeP8EkZRtgmHgTB4zmWSqAnir6iqbeM+slsYgeGvqQmvguF/wxbmO8Dr7XPSQVOJMZZnKCYN3V1+E73+N73UN+j/Mo7HNt8+E4I48zOM4Y8+nnK2eAL9UvWnPXvEU0AAAAAElFTkSuQmCC'! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:00'!greenCircleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAEdSURBVDhPnZMxTgNBDEVtZ8SGW3ADJC4QiTRQ0CHR0BJaqDgD1dZElDRIdCmoiEQOgMQJ4BYQmIzx9w4RixTYyStWO/b+mbX9h+kXF5PjbV3EU2HaJeUtD7K+JqUp98LV5cHNs8cyyw3Obw83q36oleiEiSWHWyhpssf1xzye1Ud3b4j5BhBvVOGemQdY/48+zt/jPjbxk3BydzHgQVWF2t9QM6X4tOq3V+HlSNgRNKxUDFyT4ki82+szlMWnNqNag2Ra6YXiv18CrcAkeV2MNfJF4LC8LodpKrCnj6SQPMaxuLfNnjneHdNA6x2Ety0y80QndNZoyJpowNPm7T1L/FkOcqo6xrety/STbO2RJYbf11mbST2g5vZ1JvoC3HqARbs8jn8AAAAASUVORK5CYII='! !!ICEO class methodsFor: 'utile' stamp: 'RB 4/2/2024 22:00'!blueTriangleIconContents	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAOCAYAAAAmL5yKAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAACxMAAAsTAQCanBgAAAE0SURBVDhPjZNLSgNBEIarejILQXwkV5CYuIjniCvxeYNEEVfuzQUcfOEiXkAEF648hRuzEXKHTMwwoGEyXXb1tImZnhn9oOj6q+tFQ0MRB1fhFpuRmaA5LVpdcoefYY/91YXFxn0bI32RQpjTYjgOj1X7Gpv2c8jcYPt2VClJ0VeXZdYE4E+ErD6fLg90wi8yN3Bj7PwUM+xzzMg5rA0O74J6HOEbIrgmpCGCyHFp8/Fk6d2ENNYGcgJeupjhmIzAM3LKXIPdy1FTpSrLAbGZ5MyYNmh1X101xZqQBlFccK6Rswb+19qRuqwbmYsasuGP19tGJo+4532U0XH6SlV09C8IBhTH1aezFT/ZwBGdfxcznFsqnWt35yaoCQk9RLRevggiiqSABu5fBw9AWPhhckF6+QbDPVj5ea9QcwAAAABJRU5ErkJggg=='! !SpPresenter subclass: #SgBrowser	instanceVariableNames: 'situations essences attributs qualites code'	classVariableNames: ''	package: 'ICEO'!!SgBrowser commentStamp: 'RobertBourgeois 3/24/2024 11:07' prior: 0!Browser au niveau générique d'ICEO!!SgBrowser methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 10:36'!getSituations^situations! !!SgBrowser methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 10:25'!getEssences^essences! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:03'!initializeCodePresenter	code := self newLabel ! !!SgBrowser methodsFor: 'initialization'!classTemplateFor: aSituation	aSituation ifNil: [ ^ '' ].	^ 'Object subclass: #NameOfSubclass	slots: {}	classVariables: {}	package: ''' , aSituation name , ''' '! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 4/7/2024 16:54'!initializeQualitesPresenter| icon |	qualites := self newList.	qualites		display: [ :qualite | ' ', qualite  name ];				displayIcon: [ :essence | 			essence isQualite				ifTrue: [					essence isEssentielle						ifTrue: [ icon := Smalltalk ui icons iconNamed: #redCircleIcon ]						ifFalse: [ icon := Smalltalk ui icons iconNamed: #yellowCircleIcon ] ]				ifFalse: [					icon := Smalltalk ui icons iconNamed: #blueCircleIcon ].			icon ];		whenActivatedDo: [ :selection | selection selectedItem inspect ];		sortingBlock: [ :a :b | a name < b name ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/25/2024 20:48'!initializeSituationsPresenter	situations := self newTreeTable.	situations		addColumn: (SpCompositeTableColumn new				 addColumn: ((SpImageTableColumn evaluated: [ :aSituation |							   Smalltalk ui icons iconNamed: #open ])						  width: 20;						  yourself);				 addColumn: (SpStringTableColumn evaluated: #name);				 yourself);		roots: { (Smalltalk at: #absolu) };		children: [ :aSituation | aSituation getSituations ];		whenActivatedDo: [ :selection | 			selection selectedItem inspect ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/26/2024 10:49'!connectSituationsPresenter	situations transmitTo: essences transform: [ :aSituation |		aSituation			ifNotNil: [ aSituation getEssences asArray ]			ifNil: [ #(  ) ] ].	situations transmitTo: code transform: [ :aSituation |		aSituation isNil			ifFalse: [ aSituation getDescription ]			ifTrue: [ '' ] ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/26/2024 07:37'!connectEssencesPresenter	essences		transmitTo: attributs		transform: [ :aClass | 			aClass				ifNotNil: [aClass getEssencesAttributs asArray]				ifNil: [ #(  ) ] ].			essences		transmitTo: qualites		transform: [ :aClass | 			aClass				ifNotNil: [aClass getQualites asArray]				ifNil: [ #(  ) ] ].		essences		transmitTo: code		transform: [ :aClass | aClass ifNotNil: [ aClass getDescription ] ifNil: [ '' ] ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 4/7/2024 16:54'!initializeEssencesPresenter	| icon |	essences := self newList.	essences		display: [ :essence | ' ', essence name ];				displayIcon: [ :essence |			essence isQualite				ifTrue: [					essence isEssentielle						ifTrue: [ icon := Smalltalk ui icons iconNamed: #redCircleIcon ]						ifFalse: [ icon := Smalltalk ui icons iconNamed: #yellowCircleIcon ] ]				ifFalse: [					icon := Smalltalk ui icons iconNamed: #blueCircleIcon ].			icon ];			whenActivatedDo: [ :selection | 			selection selectedItem inspect ];		sortingBlock: [ :a :b | a name < b name ]	! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 4/9/2024 11:14'!initializeAttributsPresenter	| icon |	attributs := self newList.	attributs		display: [ :attribut |			attribut getSituationDefinition isSituation				ifTrue: [ ' ' , attribut name ]				ifFalse: [					' ' , attribut name , ' de '					, attribut getSituationDefinition printString ] ];		displayIcon: [ :essence |			essence isQualite				ifTrue: [					essence isEssentielle						ifTrue: [ icon := Smalltalk ui icons iconNamed: #redCircleIcon ]						ifFalse: [							icon := Smalltalk ui icons iconNamed: #yellowCircleIcon ] ]				ifFalse: [					(essences items includes: essence getSituationDefinition)						ifTrue: [ icon := Smalltalk ui icons iconNamed: #blueCircleIcon ]						ifFalse: [							icon := Smalltalk ui icons iconNamed: #purpleCircleIcon ] ].			icon ];		whenActivatedDo: [ :selection | selection selectedItem inspect ];		sortingBlock: [ :a :b | a name < b name ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:50'!connectAttributsPresenter	attributs		transmitTo: code		transform: [ :aAttribut | aAttribut ifNotNil: [ aAttribut getDescription ] ifNil: [ '' ] ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 3/27/2024 09:36'!initializeWindow: aWindowPresenter	aWindowPresenter		title: 'Niveau générique';		initialExtent: 800 @ 250! !!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/24/2024 18:22'!initializePresenters	self initializeSituationsPresenter.	self initializeEssencesPresenter.	self initializeAttributsPresenter.	self initializeQualitesPresenter.	self initializeCodePresenter! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 15:42'!connectQualitesPresenter	qualites		transmitTo: code		transform: [ :aQualite | aQualite ifNotNil: [ aQualite getDescription ] ifNil: [ '' ] ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/25/2024 20:45'!connectPresenters	self connectSituationsPresenter.	self connectEssencesPresenter.	self connectAttributsPresenter.	self connectQualitesPresenter! !!SgBrowser methodsFor: 'layout' stamp: 'RB 3/26/2024 13:44'!defaultLayout	| situationsLayout essencesLayout qualitesLayout attributsLayout |	situationsLayout := SpBoxLayout newTopToBottom		add: 'Situations' expand: false;		add: situations;		yourself.		essencesLayout := SpBoxLayout newTopToBottom		add: 'Essences' expand: false;		add: essences;		yourself.			attributsLayout := SpBoxLayout newTopToBottom		add: 'Attributs' expand: false;		add: attributs;		yourself.			qualitesLayout := SpBoxLayout newTopToBottom		add: 'Qualités' expand: false;		add: qualites;		yourself.			^ SpBoxLayout newTopToBottom		spacing: 5;		add: (SpBoxLayout newLeftToRight			spacing: 5;			add: situationsLayout;			add: essencesLayout;			add: attributsLayout;			add: qualitesLayout;			yourself);			add: code height: 30;		yourself! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SgBrowser class	instanceVariableNames: ''!!SgBrowser class methodsFor: 'showing'!open 	<script>		^ self new open! !SpPresenter subclass: #SiBrowser	instanceVariableNames: 'situations etres attributs etats code'	classVariableNames: ''	package: 'ICEO'!!SiBrowser commentStamp: 'RobertBourgeois 3/24/2024 11:07' prior: 0!Browser au niveau individuel d'ICEO!!SiBrowser methodsFor: 'initialization' stamp: 'RB 4/3/2024 15:07'!connectEtresPresenter	etres		transmitTo: attributs		transform: [ :anEtre | 			anEtre				ifNotNil: [anEtre getAllEtresAttributs asArray]				ifNil: [ #(  ) ] ].			etres		transmitTo: etats		transform: [ :anEtre | 			anEtre				ifNotNil: [anEtre getEtats asArray]				ifNil: [ #(  ) ] ].		etres		transmitTo: code		transform: [ :anEtre | anEtre ifNotNil: [ anEtre getDescription ] ifNil: [ '' ] ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:45'!initializeCodePresenter	code := self newLabel! !!SiBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/25/2024 14:00'!initializeSituationsPresenter	situations := self newTreeTable.	situations		addColumn: (SpCompositeTableColumn new				 addColumn: ((SpImageTableColumn evaluated: [ :aSituation |							   Smalltalk ui icons iconNamed: #open ])						  width: 20;						  yourself);				 addColumn: (SpStringTableColumn evaluated: #getNom);				 yourself);		roots: { (Smalltalk at: #monde) };		children: [ :aSituation | aSituation getSituations ];		whenActivatedDo: [ :selection | 			selection selectedItem inspect ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:45'!connectSituationsPresenter	situations		transmitTo: etres		transform: [ :aSituation | 			aSituation				ifNotNil: [ aSituation getEtres asArray ] 				ifNil: [ #(  ) ] ].	situations		transmitTo: code		transform: [ :aSituation | aSituation getDescription ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 4/8/2024 16:35'!initializeAttributsPresenter	| icon |	attributs := self newList.	attributs		display: [ :attribut |			attribut getSituationDefinition isSituation				ifTrue: [					attribut isEtat						ifTrue: [							attribut getEtant isEtat								ifTrue: [									' (' , attribut getEtant getEtant getNom , ') '									, attribut getNom ]								ifFalse: [									' (' , attribut getEtant getNom , ') ' , attribut getNom ] ]						ifFalse: [ ' ' , attribut getNom ] ]				ifFalse: [' ', 					attribut getNom  ] ];		displayIcon: [ :attribut |			attribut isEtat				ifTrue: [					attribut class isEssentielle						ifTrue: [							icon := Smalltalk ui icons iconNamed: #redTriangleIcon ]						ifFalse: [							icon := Smalltalk ui icons iconNamed: #yellowTriangleIcon ] ]				ifFalse: [					attribut getSituationDefinition isSituation						ifTrue: [							icon := Smalltalk ui icons iconNamed: #purpleTriangleIcon ]						ifFalse: [							icon := Smalltalk ui icons iconNamed: #blueTriangleIcon ] ].			icon ];		whenActivatedDo: [ :selection | selection selectedItem inspect ];		sortingBlock: [ :a :b | a getNom < b getNom ] ! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:46'!connectAttributsPresenter	attributs		transmitTo: code		transform: [ :aAttribut | aAttribut ifNotNil: [ aAttribut getDescription ] ifNil: [ '' ] ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/27/2024 09:37'!initializeWindow: aWindowPresenter	aWindowPresenter		title: 'Niveau individuel';		initialExtent: 800 @ 250! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 4/7/2024 16:56'!initializeEtresPresenter	| icon |	etres := self newList.	etres		display: [ :etre |			etre isEtat				ifTrue: [					etre getEtant isEtat						ifTrue: [							' (' , etre getEtant getEtant getNom , ') ' , etre getNom ]						ifFalse: [ ' (' , etre getEtant getNom , ') ' , etre getNom ] ]				ifFalse: [ ' ' , etre getNom ] ];		displayIcon: [ :etre |			etre isEtat				ifTrue: [					etre class isEssentielle						ifTrue: [							icon := Smalltalk ui icons iconNamed: #redTriangleIcon ]						ifFalse: [							icon := Smalltalk ui icons iconNamed: #yellowTriangleIcon ] ]				ifFalse: [					icon := Smalltalk ui icons iconNamed: #blueTriangleIcon ].			icon ];		whenActivatedDo: [ :selection | selection selectedItem inspect ];		sortingBlock: [ :a :b | a getNom < b getNom ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/24/2024 18:22'!initializePresenters	self initializeSituationsPresenter.	self initializeEtresPresenter.	self initializeAttributsPresenter.	self initializeEtatsPresenter.	self initializeCodePresenter! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 4/7/2024 16:53'!initializeEtatsPresenter| icon |	etats := self newList.	etats		display: [ :etat | ' ', etat  getNom ];		displayIcon: [ :etre |			etre isEtat   				ifTrue: [					etre class isEssentielle						ifTrue: [ icon := Smalltalk ui icons iconNamed: #redTriangleIcon ] 						ifFalse: [ icon := Smalltalk ui icons iconNamed: #yellowTriangleIcon]]			ifFalse: [ icon := Smalltalk ui icons iconNamed: #blueTriangleIcon]. 			icon]; 			whenActivatedDo: [ :selection | 			selection selectedItem inspect ];		sortingBlock: [ :a :b | a getNom < b getNom ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:46'!connectEtatsPresenter	etats		transmitTo: code		transform: [ :anEtat | anEtat ifNotNil: [ anEtat getDescription ] ifNil: [ '' ] ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/24/2024 18:18'!connectPresenters	self connectSituationsPresenter.	self connectEtresPresenter.	self connectAttributsPresenter.	self connectEtatsPresenter! !!SiBrowser methodsFor: 'layout' stamp: 'RB 3/26/2024 13:46'!defaultLayout	| situationsLayout etresLayout etatsLayout attributsLayout |	situationsLayout := SpBoxLayout newTopToBottom		add: 'Situations' expand: false;		add: situations;		yourself.		etresLayout := SpBoxLayout newTopToBottom		add: 'Etres' expand: false;		add: etres;		yourself.			attributsLayout := SpBoxLayout newTopToBottom		add: 'Attributs' expand: false;		add: attributs;		yourself.			etatsLayout := SpBoxLayout newTopToBottom		add: 'Etats' expand: false;		add: etats;		yourself.			^ SpBoxLayout newTopToBottom		spacing: 5;		add: (SpBoxLayout newLeftToRight			spacing: 5;			add: situationsLayout;			add: etresLayout;			add: attributsLayout;			add: etatsLayout;			yourself);			add: code height: 30;		yourself! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SiBrowser class	instanceVariableNames: ''!!SiBrowser class methodsFor: 'showing'!open 	<script>		^ self new open! !	"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!		ICEO start !