Object subclass: #Etre	instanceVariableNames: ''	classVariableNames: ''	package: 'ICEO'!!Etre commentStamp: 'RB 3/19/2024 09:57' prior: 0!"Une essence est un être"!!Etre methodsFor: 'utile' stamp: 'RB 3/19/2024 09:58'!oups: unString"L'utilisation de breakpoints n'est pas illogique dans l'utilisation d'ICEO qui est interactive ..."	self halt: unString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Etre class	instanceVariableNames: 'structure situationDefinition isSituation isEtat etats etant nom'!!Etre class methodsFor: 'utile' stamp: 'RB 3/19/2024 09:59'!oups: unString"L'utilisation de breakpoints n'est pas illogique dans l'utilisation d'ICEO qui est interactive"	self halt: unString! !!Etre class methodsFor: 'acces' stamp: 'RB 3/19/2024 04:34'!getEtreAttribut: unStringOrSymbol 	| attributs etre symbol |	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	attributs := self getEtresAttributs.	attributs		detect: [:each | each getNom == symbol				or: [each getEssence getNom == symbol]]		ifFound: [:x | etre := x]		ifNone: [attributs				do: [:each | each getEssence getAllGenus						do: [:x | x getNom == symbol								ifTrue: [etre := each]]]].	etre isNil ifTrue: [self oups: 'attribut ', symbol, ' non trouvé'].	^ etre! !!Etre class methodsFor: 'acces' stamp: 'RB 3/19/2024 15:32'!getEtresAttributs	structure isNil		ifTrue: [structure := OrderedCollection new].	^ structure! !!Etre class methodsFor: 'acces' stamp: 'RB 2/24/2024 19:15'!getStructure"pour un être"	structure isNil		ifTrue: [structure := OrderedCollection new].	^ structure! !!Etre class methodsFor: 'acces' stamp: 'RB 2/28/2024 09:14'!setSituationDefinition: unEtre	situationDefinition := unEtre! !!Etre class methodsFor: 'acces' stamp: 'RB 2/19/2024 18:32'!getSituationDefinition	^situationDefinition! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 12:14'!getNom	^nom! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 12:55'!getEssence	^self class! !!Etre class methodsFor: 'acces' stamp: 'RB 2/16/2024 12:13'!setNom: unSymbole	nom := unSymbole! !!Etre class methodsFor: 'acces' stamp: 'RB 3/19/2024 17:30'!attributionEtre: unStringOrSymbol essence: uneEssence"prévoir des controles ..."	| etre symbole|	symbole := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	etre := uneEssence new.	etre setNom: symbole.	etre setSituationDefinition: self.	etre isSituation: false.	etre isEtat: false.	(self getStructure) add: etre! !Etre subclass: #Essence	instanceVariableNames: 'structure situationDefinition isSituation isEtat etats etant nom id description'	classVariableNames: ''	package: 'ICEO'!!Essence commentStamp: 'RB 3/19/2024 09:56' prior: 0!"superclass de toutes les essences et situations dans ICEO"!!Essence methodsFor: 'acces' stamp: 'RB 3/19/2024 10:09'!getEtat: unStringOrSymbol dansSituation: uneSituation 	|  e etre symbol |	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	e := self getEtats.	etre := e				detect: [:each | (each getEssence getNom == symbol						and: [each isEtat])						and: [uneSituation getElements includes: each]].	^ etre! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 12:14'!getNom	^nom! !!Essence methodsFor: 'acces' stamp: 'RB 2/17/2024 19:10'!getSituation: unSymbole 	"retourne, si elle existe, la première situation individuelle trouvée"	^ structure		detect: [:each | each getNom == unSymbole asSymbol]! !!Essence methodsFor: 'acces' stamp: 'RB 2/19/2024 16:28'!isGenerique	^false! !!Essence methodsFor: 'acces' stamp: 'RB 3/30/2024 09:08'!getEtresAttributsEnTantQue: uneQualite	| ee attributs |	attributs := OrderedCollection new.	ee := self getEtats.	ee do: [ :each |		each getEssence == uneQualite ifTrue: [			each getEtresAttributs do: [ :x |				x isEtat					ifTrue: [					x getEtant notNil ifTrue: [ attributs add: x getEtant ] ]					ifFalse: [ "x est un être attribut d'un état" attributs add: x ] ] ] ].	^ attributs! !!Essence methodsFor: 'acces' stamp: 'RobertBourgeois 3/25/2024 07:56'!getSituations	"pour une situation"	| situations |	self isSituation		ifFalse: [self oups: 'la méthode getSituations ne s''applique qu''à une situation'].		situations := OrderedCollection new.	self getStructure		do: [:each | each isSituation				ifTrue: [situations add: each ]].	^ situations! !!Essence methodsFor: 'acces' stamp: 'RB 2/28/2024 16:55'!removeEtat: unEtat		self getEtats remove: unEtat.! !!Essence methodsFor: 'acces' stamp: 'RB 2/24/2024 13:57'!getElements"pour une situation"	structure isNil		ifTrue: [structure := OrderedCollection new].	^ structure! !!Essence methodsFor: 'acces' stamp: 'RB 3/19/2024 04:34'!get: unStringOrSymbol 	"pour une situation"	"retourne, s'il existe, l'etre trouvé"	| symbol etres |	self isSituation		ifFalse: [self oups: self getNom , ' n''est pas une situation'].	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	etres := self getStructure				select: [:each | each getNom == symbol].	etres size == 0		ifTrue: [self oups: 'être de nom' , symbol , ' non trouvé dans la situation ' , self getNom].	etres size > 1		ifTrue: [etres := self getStructure						select: [:each | each getNom == symbol								and: [each getEtats size == 0]].			etres size == 0				ifTrue: [self oups: 'aucun être sans état de nom ' , symbol , ' ne se trouve dans la situation ' , self getNom]].	etres size > 1		ifTrue: [self oups: etres size printString , ' êtres de nom ' , symbol , ' se trouvent dans la situation ' , self getNom].	^ etres at: 1! !!Essence methodsFor: 'acces' stamp: 'RB 3/19/2024 10:12'!referenceEtre: unEtre	self getEssence getEssencesAttributs		detect: [ :each | each == unEtre getEssence ]		ifFound: [ :a |			(self getStructure includes: unEtre)				ifTrue: [					self oups:						'un être ' , unEtre , ' est déjà présente dans ' , self getNom ]				ifFalse: [ self getStructure add: unEtre ] ]		ifNone: [			self oups: 'attributEssence ' , unEtre getEssence getNom				, ' non défini pour l''essence ' , self getEssence getNom ]! !!Essence methodsFor: 'acces' stamp: 'RB 2/24/2024 15:46'!attributionEtre: unEtre"pour un être"	structure isNil ifTrue: [structure := OrderedCollection new].	structure add: unEtre! !!Essence methodsFor: 'acces' stamp: 'RB 3/30/2024 08:12'!addEtatEssentiel: uneQualite 	"il faudra vérifier que self peut avoir cet etat !!!! "		| etat |	uneQualite isQualite ifFalse: [self oups: uneQualite , 'n''est pas une qualité'].	etat := uneQualite new.	self getEtats add: etat.	etat setEtant: self.	etat isEtat: true.	etat isSituation: false.	etat setSituationDefinition: self.		"par défaut"	etat setNom: uneQualite getNom.	etat setDescription: self getNom printString, ' addEtatEssentiel: ', uneQualite getNom printString.		Smalltalk at: #sib ifPresent: [:x | x window close].! !!Essence methodsFor: 'acces' stamp: 'RB 3/30/2024 08:12'!addEtat: uneQualite dansSituation: uneSituationIndividuelle 	"il faudra vérifier que self peut avoir cet etat !!!! "	| etat |	uneQualite isQualite ifFalse: [self oups: uneQualite , 'n''est pas une qualité'].	etat := uneQualite new.	self getEtats add: etat.	etat setEtant: self.	etat isEtat: true.	etat isSituation: false.	uneSituationIndividuelle add: etat.	etat setSituationDefinition: uneSituationIndividuelle.		"par défaut"	etat setNom: uneQualite getNom.	etat setDescription: self getNom printString, ' addEtat: ', uneQualite getNom printString, ' dansSituation: ', uneSituationIndividuelle getNom printString.		Smalltalk at: #sib ifPresent: [:x | x window close].! !!Essence methodsFor: 'acces' stamp: 'RB 3/30/2024 08:13'!attributionEtre: unStringOrSymbol essence: uneEssence"pour un être"	| symbol attribut |			symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].  	structure isNil ifTrue: [structure := OrderedCollection new].		attribut := uneEssence new. 	attribut setNom: symbol.		structure add: attribut.	attribut setSituationDefinition: self.	attribut setDescription: self getNom printString, ' attributionEtre ', unStringOrSymbol, ' essence: ', uneEssence getNom printString.		Smalltalk at: #sib ifPresent: [:x | x window close].! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 11:38'!isSituation: aBoolean	isSituation := aBoolean! !!Essence methodsFor: 'acces' stamp: 'RB 2/19/2024 18:32'!getSituationGenerique	^self class! !!Essence methodsFor: 'acces' stamp: 'RB 3/19/2024 15:33'!getEtresAttributs	| attributs |  	structure isNil		ifTrue: [structure := OrderedCollection new].	attributs := OrderedCollection new, structure. 	self getEssence getEtresAttributs		do: [:each | each getEssence isPrototype 				ifTrue: [attributs add: each]].	^ attributs! !!Essence methodsFor: 'acces' stamp: 'RB 2/25/2024 21:23'!getEtresAttributsQuiSont: uneQualite 	| attributs |	attributs := OrderedCollection new.	self getEtats 		do: [:e |			e getEtresAttributs				do: [:ao | (ao getEssence == uneQualite							or: [ao getEssence getGenus == uneQualite])						ifTrue: [ao getEtant == nil								ifFalse: [attributs add: ao getEtant]]].			e getEtats				do: [:ao | ao getEtresAttributs						do: [:etat | (etat getEssence == uneQualite									or: [etat getEssence getGenus == uneQualite])								ifTrue: [etat getEtant == nil										ifFalse: [attributs add: etat getEtant]]]]].	^ attributs! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 18:56'!getEtats	etats isNil ifTrue: [etats := OrderedCollection new].	^etats! !!Essence methodsFor: 'acces' stamp: 'RB 2/24/2024 19:15'!getStructure"pour un être"	structure isNil		ifTrue: [structure := OrderedCollection new].	^ structure! !!Essence methodsFor: 'acces' stamp: 'RB 3/13/2024 17:53'!getTousEtresAttributs	"inclut les attributs acquis par les états"	| attributs |	attributs := self getEtresAttributs.	self getEtats		do: [:each | each getEtresAttributs size > 0 ifTrue: [attributs add: (each getEtresAttributs at: 1) getEtant]].	^ attributs! !!Essence methodsFor: 'acces' stamp: 'RB 3/28/2024 14:26'!setDescription: unString	description := unString! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 12:13'!setNom: unSymbole	nom := unSymbole! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 11:37'!isEtat: aBoolean	isEtat := aBoolean! !!Essence methodsFor: 'acces' stamp: 'RB 3/19/2024 04:28'!associationEtat: unEtat"association bidirectionnellle de self et de unEtat"	self isEtat ifFalse: [self oups: self getNom, ' n''est pas un   état'].	unEtat isEtat ifFalse: [self oups: unEtat getNom, ' n''est pas un état'].	"situationDefinition == unEtat getSituationDefinition ifFalse: [self halt: unEtat getNom, ' et ', self getNom, ' ne sont pas définis dans la même situation'].	"			self getStructure  add: unEtat.	unEtat getStructure add: self! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 19:01'!setEtant: unEtre	etant := unEtre! !!Essence methodsFor: 'acces' stamp: 'RB 2/29/2024 10:31'!getElementsEssence: uneEssence"pour une situation, retourne l'ensemble des êtres ayant uneEssence pour essence"	^self getEtresAttributs select: [:each | each getEssence == uneEssence]! !!Essence methodsFor: 'acces' stamp: 'RB 2/24/2024 14:13'!add: unEtre"pour une situation individuelle"	structure isNil ifTrue: [structure := OrderedCollection new].	structure add: unEtre! !!Essence methodsFor: 'acces' stamp: 'RB 3/11/2024 08:50'!getEtat: unSymbole 	| states |	states := etats				select: [:each | each getNom == unSymbole].	states size == 0		ifTrue: [^ nil].	^ states  at: 1! !!Essence methodsFor: 'acces' stamp: 'RB 2/28/2024 09:14'!setSituationDefinition: unEtre	situationDefinition := unEtre! !!Essence methodsFor: 'acces' stamp: 'RobertBourgeois 3/25/2024 08:05'!getEtres	^self getElements select: [:each | each isSituation not]! !!Essence methodsFor: 'acces' stamp: 'RB 3/19/2024 04:33'!get: unStringOrSymbol quiEst: uneQualite 	"pour une situation"	"retourne, s'il existe avec la qualité uneQualité, l'etre trouvé"	| symbol etres |	self isSituation		ifFalse: [self oups: self getNom , ' n''est pas une situation'].	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	etres := self getStructure				select: [:each | each getNom == symbol						and: [(each getEtat: uneQualite getNom) notNil]].	etres size == 0		ifTrue: [self oups: 'être de nom' , symbol , ' non trouvé dans la situation ' , self getNom].	etres size > 1		ifTrue: [self oups: etres size printString , ' êtres de nom ' , symbol , ' se trouvent dans la situation ' , self getNom].	^ etres  at: 1! !!Essence methodsFor: 'acces' stamp: 'RB 3/10/2024 22:40'!getId	" permet de différencier deux êtres de même nom"	id isNil ifTrue: [id := (self class genSym: nom)].	^id! !!Essence methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 07:29'!getDescription	^description isNil ifTrue: ['tbd'] ifFalse: [ description ]! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 11:37'!isSituation	^isSituation! !!Essence methodsFor: 'acces' stamp: 'RB 3/6/2024 18:41'!isEtat	isEtat isNil ifTrue: [isEtat := false].	^isEtat ! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 19:01'!getEtant	^etant! !!Essence methodsFor: 'acces' stamp: 'RB 2/19/2024 18:32'!getSituationDefinition	^situationDefinition! !!Essence methodsFor: 'acces' stamp: 'RB 2/16/2024 12:55'!getEssence	^self class! !!Essence methodsFor: 'acces' stamp: 'RB 3/19/2024 04:34'!getEtreAttribut: unStringOrSymbol 	| attributs etre symbol |	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	attributs := self getEtresAttributs.	attributs		detect: [:each | each getNom == symbol				or: [each getEssence getNom == symbol]]		ifFound: [:x | etre := x]		ifNone: [attributs				do: [:each | each getEssence getAllGenus						do: [:x | x getNom == symbol								ifTrue: [etre := each]]]].	etre isNil ifTrue: [self oups: 'attribut ', symbol, ' non trouvé'].	^ etre! !!Essence methodsFor: 'methodes' stamp: 'RB 2/28/2024 21:51'!resetStructure	structure := OrderedCollection new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Essence class	instanceVariableNames: 'differentia isQualite isIndividu isAttributPropre isPrototype statut effectivite qualites essencesQualifiees metaEssence cardinalite id description'!!Essence class methodsFor: 'methodes' stamp: 'RB 3/19/2024 08:13'!est: uneQualite 	uneQualite isQualite		ifFalse: [self oups: uneQualite , ' n''est pas une qualité'].		uneQualite getStatut == #essentielle		ifFalse: [self oups: uneQualite , ' n''est pas une qualité essentielle'].	qualites isNil		ifTrue: [qualites := OrderedCollection new].	qualites add: uneQualite.	uneQualite getEssencesQualifiees add: self! !!Essence class methodsFor: 'methodes' stamp: 'RB 2/26/2024 16:45'!specialise: uneEssence 	^self allSuperclasses includes: uneEssence  		! !!Essence class methodsFor: 'methodes' stamp: 'RB 2/18/2024 18:21'!subsume: uneEssence 	self == uneEssence		ifTrue: [^ true].	uneEssence getNom == #chose		ifTrue: [^ false].	^ self subsume: uneEssence getGenus! !!Essence class methodsFor: 'methodes' stamp: 'RB 2/26/2024 18:21'!getInstance: unStringOrSymbol 	"création d'un être hypothétique instance de self "	| symbol etre |	symbol := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	etre := self new.	etre setNom: symbol.	etre isSituation: false.	etre isEtat: false.	^etre		! !!Essence class methodsFor: 'methodes' stamp: 'RB 3/19/2024 04:36'!peutEtre: uneQualite 	uneQualite isQualite		ifFalse: [self oups: uneQualite getNom, ' n''est pas une qualité'].	qualites isNil		ifTrue: [qualites := OrderedCollection new].	qualites add: uneQualite.	uneQualite getEssencesQualifiees add: self! !!Essence class methodsFor: 'methodes' stamp: 'RB 3/19/2024 17:57'!referenceEssence: uneEssence 	"ne change pas la situation de définition de l'essence"	(self getDifferentia		includes: uneEssence getNom)		ifTrue: [self oups: 'une essence de nom ' , uneEssence , ' est déjà présente dans ' , self getNom]		ifFalse: [self getDifferentia add: uneEssence]! !!Essence class methodsFor: 'utile' stamp: 'RB 3/19/2024 11:54'!genSym: aSymb 	"generateur de symboles"	| n gs |	gs := Smalltalk at: #GenSym.	n := gs at: aSymb ifAbsent: [n := -1].	n := n + 1.	gs at: aSymb put: n.	^(aSymb , '_', n printString) asSymbol! !!Essence class methodsFor: 'utile' stamp: 'RB 3/19/2024 14:46'!createFreeSubclass: aSymbol	| newClass |	"not installed in the system"	newClass := self newAnonymousSubclass setName: aSymbol.	subclasses isNil		ifTrue: [ self subclasses: (Array with: newClass) ]		ifFalse: [ self subclasses: (subclasses copyWith: newClass) ].	^ newClass! !!Essence class methodsFor: 'acces' stamp: 'RB 2/15/2024 11:37'!getNom	^ name! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 08:17'!getSituation: unStringOrSymbol"retourne la situation unStringOrSymbol incluse dans une situation"	| n env |	self isSituation		ifFalse: [self oups: 'la méthode getEssences: ne s''applique qu''à une situation'].	n := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	env := self getDifferentia				collect: [:each | each value].	^ env		detect: [:each | each name == n and: [each isBehavior				and: [each isSituation]]]		ifNone: [self oups: 'situation ' , n , ' non trouvée dans la situation ' , self name]! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 04:36'!isGenerique	self isSituation ifFalse: [self oups: 'seule une situation peut être générique'].	^true! !!Essence class methodsFor: 'acces' stamp: 'RobertBourgeois 3/25/2024 23:33'!getEssencesAttributs	"attributs propres et hérités mais non surchargés pour une essence"	| attributs temp |	self isSituation		ifTrue: [self oups: 'la méthode getEssencesAttributs ne s''applique qu''à une essence'].		attributs := OrderedCollection new , self getDifferentia.   	((self			~~ Essence) and: [superclass			~~ (Smalltalk at: #chose)]) 		ifTrue: [attributs addAll: superclass getEssencesAttributs].	"ne garder que les essences non surchargées"	temp := OrderedCollection new, attributs.	attributs		do: [:each | attributs				do: [:att |   (att getAllGenusWithoutMe includes: each)						ifTrue: [temp								remove: each								ifAbsent: []]]].					temp do: [ :each | (self getDifferentia includes: each) ifTrue: [each isAttributPropre: true] ifFalse: [each isAttributPropre: false]].	^ temp! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 15:58'!getSituations	"pour une situation"	| situations |	self isSituation		ifFalse: [self oups: 'la méthode getSituations ne s''applique qu''à une situation'].		situations := OrderedCollection new.	self getDifferentia		do: [:each | each isSituation				ifTrue: [situations add: each ]].	^ situations! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 08:16'!getQualitesPropres		self isSituation		ifTrue: [self oups: 'la méthode getQualites ne s''applique qu''à une essence'].	qualites isNil ifTrue: [qualites := OrderedCollection new].			^qualites! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 13:37'!getAllGenusWithoutMe	| c |	(self name == #Essence			or: [self name == #absolu])		ifTrue: [^ OrderedCollection new].	c := OrderedCollection with: self.	self name == #chose		ifFalse: [c addAll: self getGenus getAllGenus].	^ c copyWithout: self! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 04:11'!getDifferentia	"retourne l'ensemble des attributs propres"	differentia isNil ifTrue: [ differentia := OrderedCollection new] .	^ differentia! !!Essence class methodsFor: 'acces' stamp: 'RB 3/24/2024 09:55'!isEssentielle	statut isNil ifTrue: [^false].	^self getStatut == #essentielle  ! !!Essence class methodsFor: 'acces' stamp: 'RobertBourgeois 3/25/2024 21:20'!getElements	"retourne l'ensemble des éléments inclus dans une situation"	self isSituation		ifTrue: [^ self getDifferentia]		ifFalse: [self oups: 'la méthode getElements ne s''applique qu''à une situation']! !!Essence class methodsFor: 'acces' stamp: 'RB 2/24/2024 14:08'!get: unStringOrSymbol 	"retourne l'essence unStringOrSymbol incluse dans une situation"	^self getElement: unStringOrSymbol! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 08:15'!getEssencesAttributs: unSymbole 	| attributs |	attributs := self getEssencesAttributs				select: [:each | each name == unSymbole].. 	attributs size == 0		ifTrue: [self getEssencesAttributs				do: [:each | each allSuperclasses						do: [:sup | sup name == unSymbole								ifTrue: [attributs add: each]]]].	attributs size == 0		ifTrue: [self oups: self name , ' ne possède pas d''attribut de nom ' , unSymbole].	^ attributs! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 10:23'!associationQualite: uneQualite 	"association bidirectionnellle de self et de uneQualite"	self isQualite		ifFalse: [self oups: self getNom , ' n''est pas une qualité'].	uneQualite isQualite		ifFalse: [self oups:  uneQualite getNom , ' n''est pas une qualité'].	"situationDefinition == uneQualite getSituationDefinition ifFalse: [self	halt: uneQualite getNom, ' et ', self getNom, ' ne sont pas définies	dans la même situation'].	"	self getDifferentia add: uneQualite.	" attribution corrélative, sauf s'il s'agit d'une qualite de self. Par exemple, être soeur pour une soeur ... "	self == uneQualite		ifFalse: [uneQualite getDifferentia add: self]! !!Essence class methodsFor: 'acces' stamp: 'RB 2/28/2024 08:32'!getCardinalite	^ cardinalite! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 21:15'!isQualite isQualite isNil ifTrue: [isQualite := false].^isQualite! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 11:32'!isSituation: aBoolean	isSituation := aBoolean! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 12:39'!getEssenceAttribut: unStringOrSymbol 	| attributs symbole |	symbole := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	attributs := self getEssencesAttributs				select: [:each | each name == symbole].  	attributs size == 0		ifTrue: [self getEssencesAttributs				do: [:each | . each getAllGenus 						do: [:sup | sup name == symbole								ifTrue: [attributs add: each]]]].	attributs size == 0		ifTrue: [self oups: self name , ' ne possède pas d''attribut de nom ' , symbole , '  ou subsumé par ' , symbole].	attributs size > 1		ifTrue: [self oups: self name , ' possède ' , attributs size printString, ' attributs de nom ' , symbole , '  ou subsumés par ' , symbole].	^ attributs at: 1! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 08:15'!getQualite: unStringOrSymbol 	"retourne l'essence unStringOrSymbol incluse dans les qualités d'une essence "	| n |	n := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	^ self getQualites		detect: [:each | each name == n]		ifNone: [self oups: 'qualité ' , unStringOrSymbol , ' non trouvée pour ' , name]! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 17:31'!getEffectivite	effectivite isNil ifTrue: [effectivite := #intermittente].	^effectivite! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 17:58'!getEssencesQualifiees	essencesQualifiees isNil ifTrue: [essencesQualifiees := OrderedCollection new].	 	^essencesQualifiees! !!Essence class methodsFor: 'acces' stamp: 'RB 2/28/2024 08:34'!setCardinalite: uneValeur	^ cardinalite := uneValeur! !!Essence class methodsFor: 'acces' stamp: 'RobertBourgeois 3/25/2024 23:37'!isAttributPropreisAttributPropre isNil ifTrue: [isAttributPropre := false ].	^ isAttributPropre ! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 08:15'!getQualites	"qualités propres et hérités mais non surchargées pour une essence"	| me temp |	self isSituation		ifTrue: [self oups: 'la méthode getQualites ne s''applique qu''à une essence'].	qualites isNil ifTrue: [qualites := OrderedCollection new].		me := qualites				collect: [:each | each].	superclass			== (Smalltalk at: #Essence)		ifFalse: [me addAll: superclass getQualites].	"ne garder que les essences non surchargées"	temp := me				collect: [:each | each].	me		do: [:each | temp				do: [:att | (each subclasses includes: att)						ifTrue: [temp								remove: each								ifAbsent: []]]].	^ temp! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 10:15'!resetDifferentia	differentia := OrderedCollection new! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 10:54'!getMetaEssence	^metaEssence! !!Essence class methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 07:32'!setDescription: aString	description := aString! !!Essence class methodsFor: 'acces' stamp: 'RB 2/24/2024 16:22'!isPrototype	isPrototype == nil ifTrue: [isPrototype := false]. ^isPrototype! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 08:14'!getElement: unStringOrSymbol 	"retourne l'essence unStringOrSymbol incluse dans une situation"	| n |	self isSituation		ifFalse: [self oups: 'la méthode getEssence: ne s''applique qu''à une situation'].	n := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol]. 	^ differentia		detect: [:each | each name == n and: [each isSituation not]]		ifNone: [self oups: 'essence ' , n , ' non trouvée dans la situation ' , self name]! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 12:57'!getAllGenus	| c |	(self name == #Essence			or: [self name == #absolu])		ifTrue: [^ OrderedCollection new].	c := OrderedCollection with: self.	self name == #chose		ifFalse: [c addAll: self getGenus getAllGenus].	^ c! !!Essence class methodsFor: 'acces' stamp: 'RB 2/22/2024 18:25'!isPrototype: aBoolean	isPrototype := aBoolean! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 18:14'!setEffectivite: unSymbole	effectivite := (OrderedCollection with: #permanente  with: #intermittente) detect: [:i | i = unSymbole]! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 10:51'!isChose	^ self getAllGenus		detect: [:each | each name == #chose]		ifFound: [:x | true]		ifNone: [false]! !!Essence class methodsFor: 'acces' stamp: 'RB 2/18/2024 23:56'!setStatut: unSymbole 	statut := (OrderedCollection with: #accidentelle with: #essentielle)				detect: [:i | i = unSymbole]! !!Essence class methodsFor: 'acces' stamp: 'RB 2/15/2024 12:34'!setSituationDefinition: uneEssence	situationDefinition := uneEssence! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 17:30'!getStatut	statut isNil ifTrue: [statut := #accidentelle].	^statut! !!Essence class methodsFor: 'acces' stamp: 'RobertBourgeois 3/25/2024 23:35'!isAttributPropre: aBoolean	^ isAttributPropre := aBoolean! !!Essence class methodsFor: 'acces' stamp: 'RB 2/16/2024 11:32'!isQualite: aBoolean	isQualite := aBoolean! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 22:11'!getId	" permet de différencier deux essences de même nom"	id isNil ifTrue: [id := (self genSym: name)].	^id! !!Essence class methodsFor: 'acces' stamp: 'RB 2/28/2024 08:54'!isIndividu"true par défaut" isIndividu == nil ifTrue: [isIndividu := true]. ^isIndividu! !!Essence class methodsFor: 'acces' stamp: 'RB 2/23/2024 12:45'!setMetaEssence: uneEssence	metaEssence := uneEssence! !!Essence class methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 07:31'!getDescription	^description isNil ifTrue: ['tbd'] ifFalse: [ description ]! !!Essence class methodsFor: 'acces' stamp: 'RB 2/28/2024 08:55'!isIndividu: aBoolean"true par défaut" isIndividu := aBoolean! !!Essence class methodsFor: 'acces' stamp: 'RB 3/10/2024 21:29'!isSituation	isSituation isNil		ifTrue: [isSituation := false].	^ isSituation! !!Essence class methodsFor: 'acces' stamp: 'RB 2/15/2024 13:12'!getGenus	^ name == #chose		ifTrue: [self]		ifFalse: [superclass]! !!Essence class methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 06:54'!getSituationDefinition		^situationDefinition! !!Essence class methodsFor: 'acces' stamp: 'RB 3/19/2024 10:17'!setId: unSymbole	" permet de différencier deux essences de même nom pour nous, pauvres lecteurs humains"	id := unSymbole! !!Essence class methodsFor: 'acces' stamp: 'RB 2/24/2024 13:56'!getEssence	"par défaut, l'essence d'une essence est l'essence chose"	metaEssence == nil		ifTrue: [metaEssence := Smalltalk at: #chose].	^ metaEssence! !!Essence class methodsFor: 'acces' stamp: 'RB 3/24/2024 08:21'!getEssences	^self getElements select: [:each | each isSituation not]! !Object subclass: #ICEO	instanceVariableNames: ''	classVariableNames: ''	package: 'ICEO'!!ICEO commentStamp: 'RB 3/19/2024 09:54' prior: 0!"Interprète du langage ICEO"!!ICEO methodsFor: 'etres' stamp: 'RB 3/28/2024 17:37'!soitEtat: unStringOrSymbol essence: uneQualite situationIndividuelle: uneSituation	"définition dans uneSituationIndividuelle d'un état d'essence	uneQualite dont l'étant est indéterminé"	| nom etat essence |	nom := unStringOrSymbol isSymbol ifTrue: [ unStringOrSymbol ].	uneQualite isQualite ifFalse: [		self oups: uneQualite , 'n''est pas une qualité' ].	etat := uneQualite new.	etat setNom: nom.	etat setSituationDefinition: uneSituation.	etat isSituation: false.	etat isEtat: true.	uneSituation add: etat.	"recherche de l'essence ayant cette qualité"	essence := self class getPremierGenusCommun:		           uneQualite getEssencesQualifiees.	etat setEtant: (essence getInstance:			 'un(e) ' , essence getNom , ' inconnu(e)').	etat setDescription: 'soitEtat: ', nom, ' essence: ', uneQualite getNom, ' situationIndioviduelle: ', uneSituation getNom printString.	Smalltalk at: #sib ifPresent: [:x | x window close].! !!ICEO methodsFor: 'etres' stamp: 'RB 3/28/2024 18:47'!soit: unStringOrSymbol situationGenerique: uneSituationGenerique situationIndividuelle: uneSituationIndividuelle	"définition dans uneSituationIndividuelle d'une situation individuelle	instance de la situation générique uneSituation"	"exige que uneSituationIndividuelle soit instance d'une situation	générique où se situe une situationGenerique"	| nom situation |	(uneSituationIndividuelle getSituationGenerique includes:		 uneSituationGenerique) ifFalse: [		self oups:			uneSituationGenerique , ' doit être incluse dans l''essence de '			, uneSituationIndividuelle ].	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	situation := uneSituationGenerique new.	situation setNom: nom.	situation setSituationDefinition: uneSituationIndividuelle.	situation isSituation: true.	situation setDescription: 'soit: ', nom, ' situationGenerique ', uneSituationGenerique getNom, ' situationIndividuelle: ', uneSituationIndividuelle getNom printString.		Smalltalk at: #sib ifPresent: [:x | x window close].! !!ICEO methodsFor: 'etres' stamp: 'RB 3/28/2024 18:47'!soit: unStringOrSymbol essence: uneEssence situationIndividuelle: uneSituation	"définition dans uneSituationIndividuelle d'un être d'essence	uneEssence"	| nom etre c n |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	uneSituation getElements		detect: [ :each |		each getNom == nom and: [ each getEssence == uneEssence ] ]		ifFound: [ :x |			self oups: 'un être nommé ''' , x				, ''' de même essence existe déjà dans la situation'				, uneSituation ].	etre := uneEssence new.	etre setNom: nom.	etre setSituationDefinition: uneSituation.	uneSituation add: etre.	etre isSituation: false.	etre isEtat: false.	"création des attributs dont la cardinalite est définie et > 0"	uneEssence isIndividu ifTrue: [		uneEssence getEssencesAttributs do: [ :each |			c := each getCardinalite.			(c notNil and: [ c > 0 ]) ifTrue: [				(1 to: c) do: [ :x |					n := uneEssence genSym: each getNom.					self soit: n essence: each situationIndividuelle: etre ] ] ] ].	"les états essentiels se situent dans la situation de définition l'être"	uneEssence getQualites do: [ :each |		(each getStatut == #essentielle and: [			 each getEffectivite == #permanente ]) ifTrue: [			etre addEtatEssentiel: each  ] ].	etre setDescription: 'soit: ', nom, ' essence: ', uneEssence getNom, ' situationIndividuelle: ', uneSituation getNom printString.	Smalltalk at: #sib ifPresent: [:x | x window close].	^ etre! !!ICEO methodsFor: 'etres' stamp: 'RB 3/30/2024 08:09'!soit: unStringOrSymbol situationGenerique: uneSituation	"définition dans le monde d'une situation individuelle  instance de la situation générique uneSituation définie dans l'absolu"	| nom situation |	nom := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	situation := uneSituation new.	situation setNom: nom.	situation setSituationDefinition: (Smalltalk at: #monde).	situation isSituation: true.	(Smalltalk at: #monde) add: situation.	situation setDescription: 'soit: ', nom printString, ' situationGenerique ', uneSituation getNom.	Smalltalk at: #sib ifPresent: [:x | x window close].! !!ICEO methodsFor: 'etres' stamp: 'RB 3/28/2024 18:47'!soit: unStringOrSymbol essence: uneEssence situationIndividuelle: uneSituation quiEst: uneQualite	"définition dans uneSituationIndividuelle d'un être d'essence	uneEssence ayant un état instance de uneQualité"	| nom etre c n |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	" deux êtres de même nom ne peuvent exister dans la même situation s'ils ne se distinguent pas par leur état"	uneSituation getElements		detect: [ :each |			(each getNom == nom and: [ each getEssence == uneEssence ]) and: [				(each getEtat: uneQualite getNom) notNil ] ]		ifFound: [ :x |			self oups: 'un être nommé ''' , x getNom				, ''' de même essence existe déjà dans la situation'				, uneSituation , ' avec la même qualité ' , uneQualite getNom ].	etre := uneEssence new.	etre setNom: nom.	etre setSituationDefinition: uneSituation.	uneSituation add: etre.	etre isSituation: false.	etre isEtat: false.	(Smalltalk at: #monde) add: etre.	etre addEtat: uneQualite dansSituation: uneSituation.	"création des attributs dont la cardinalite est définie et > 0"	uneEssence isIndividu ifTrue: [		uneEssence getEssencesAttributs do: [ :each |			c := each getCardinalite.			(c notNil and: [ c > 0 ]) ifTrue: [				(1 to: c) do: [ :x |					n := uneEssence genSym: each getNom.					etre attributionEtre: (self soit: n essence: each) ] ] ] ].	"les états essentiels se situent dans la situation de définition l'être"	uneEssence getQualites do: [ :each |		(each getStatut == #essentielle and: [			 each getEffectivite == #permanente ]) ifTrue: [			etre addEtat: each dansSituation: etre getSituationDefinition ] ].	etre setDescription: 'soit: ', nom, ' essence: ', uneEssence getNom, ' situationIndividuelle: ', uneSituation getNom printString, ' quiEst: ', uneQualite getNom printString.		Smalltalk at: #sib ifPresent: [:x | x window close].	^ etre! !!ICEO methodsFor: 'etres' stamp: 'RB 3/30/2024 08:11'!soit: unStringOrSymbol essence: uneEssence	"définition dans le monde d'un être d'essence uneEssence"	| nom etre c n |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(Smalltalk at: #monde) getElements		detect: [ :each |		each getNom == nom and: [ each getEssence == uneEssence ] ]		ifFound: [ :x |			self oups: 'un être nommé ''' , x getNom				, ''' de même essence existe déjà dans le monde' ].	etre := uneEssence new.	etre setNom: nom.	etre setSituationDefinition: (Smalltalk at: #monde).	etre isSituation: false.	etre isEtat: false.	(Smalltalk at: #monde) add: etre.	"création des attributs dont la cardinalite est définie et > 0"	uneEssence isIndividu ifTrue: [		uneEssence getEssencesAttributs do: [ :each |			c := each getCardinalite.			(c notNil and: [ c > 0 ]) ifTrue: [				(1 to: c) do: [ :x |					n := uneEssence genSym: each getNom.					self soit: n essence: each situationIndividuelle: etre ] ] ] ].	"les états essentiels se situent dans la situation de définition l'être"	uneEssence getQualites do: [ :each |		(each getStatut == #essentielle and: [			 each getEffectivite == #permanente ]) ifTrue: [			etre addEtat: each dansSituation: etre getSituationDefinition ] ].	etre setDescription: 'soit: ', nom, ' essence: ', uneEssence getNom.	Smalltalk at: #sib ifPresent: [:x | x window close].	^ etre! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:14'!definitionAttribut: unStringOrSymbol de: uneEssence cardinalite: uneValeur	"définition dans le differentia de une essence d'une essence subsumée par chose"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			self oups: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := (Smalltalk at: #chose) createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	attribut setCardinalite: uneValeur.	uneEssence getDifferentia add: attribut.	attribut isSituation: false.	attribut setDescription: 'definitionAttribut: ', unStringOrSymbol printString, ' de: ', uneEssence getNom printString, ' cardinalité: ', uneValeur printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:21'!definitionQualite: unStringOrSymbol situation: uneSituation 	"définition dans uneSituation d'une manière d'être subsumée par chose "	| nom essence |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneSituation getElements		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			self oups: 'une essence nommée ''' , x getNom, ''' existe déjà dans '				, uneSituation getNom ].	essence := (Smalltalk at: #chose) createFreeSubclass: nom.	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneSituation.	uneSituation getDifferentia add: essence.	essence isSituation: false.	essence isQualite: true.	essence setStatut: #accidentelle.	essence setEffectivite: #intermittente.	essence setDescription: 'definitionQualite: ', unStringOrSymbol printString, ' situation: ', uneSituation getNom printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 13:07'!definition: unStringOrSymbol 	"définition dans absolu d'une essence subsumée par chose"	| nom essence | 	nom := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].   	(nom at: 1) isLowercase ifFalse: [self oups: 'le nom commun d''une essence doit commencer par une minuscule'].	(Smalltalk at: #absolu)  getElements		detect: [:each | each getNom == nom]		ifFound: [:x | self oups: 'une essence nommée ''' , x getNom, ''' existe déjà dans l''absolu']. 	essence := (Smalltalk at: #chose) createFreeSubclass: nom.	(Smalltalk at: #Lexique)		add: nom.	Smalltalk		at: nom		put: essence.	essence setSituationDefinition: (Smalltalk at: #absolu).	(Smalltalk at: #absolu) getDifferentia add: essence.	essence isSituation: false.	essence isQualite: false.	essence setDescription: 'definition: ', unStringOrSymbol printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]	! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:10'!definition: unStringOrSymbol genus: uneEssence metaEssence: uneAutreEssence	"définition dans l'absolu d'une essence subsumée par uneEssence et instance de uneAutreEssence"	| nom essence |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	(Smalltalk at: #absolu) getElements		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			self oups:				'une essence nommée ''' , x getNom				, ''' existe déjà dans l''absolu' ].	essence := uneEssence createFreeSubclass: nom.	essence setMetaEssence: uneAutreEssence.	(Smalltalk at: #Lexique) add: nom.	Smalltalk at: nom put: essence.	essence setSituationDefinition: (Smalltalk at: #absolu).	(Smalltalk at: #absolu) getDifferentia add: essence.	essence isSituation: false.	essence isQualite: false.	essence setDescription: 'definition: ', unStringOrSymbol printString, ' genus: ', uneEssence getNom printString, ' métEssence ', uneAutreEssence getNom printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:20'!definitionAttribut: unStringOrSymbol de: uneEssence isPrototype: aBoolean cardinalite: uneValeur	"définition dans le differentia de une essence d'une essence subsumée par chose qui est prototype"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			self oups: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := (Smalltalk at: #chose) createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	attribut setCardinalite: uneValeur.	uneEssence getDifferentia add: attribut.	attribut isSituation: false.	attribut isPrototype: aBoolean.	attribut setCardinalite: uneValeur.	attribut setDescription: 'definitionAttribut: ', unStringOrSymbol printString, ' de: ', uneEssence getNom printString, ' isProtype: ', aBoolean printString, ' cardinalité: ', uneValeur printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RobertBourgeois 3/26/2024 11:47'!definition: unStringOrSymbol situation: uneSituation	"définition dans uneSituation d'une essence subsumée par chose"	| nom essence |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneSituation getElements		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			self oups: 'une essence nommée ''' , x getNom, ''' existe déjà dans '				, uneSituation getNom ].	essence := (Smalltalk at: #chose) createFreeSubclass: nom.	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneSituation.	uneSituation getDifferentia add: essence.	essence isSituation: false.	essence isQualite: false.	essence setDescription: 'definition: ', unStringOrSymbol printString, ' situation: ', uneSituation getNom printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:18'!definitionAttribut: unStringOrSymbol de: uneEssence isPrototype: aBoolean	"définition dans le differentia de une essence d'une essence subsumée par chose"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			self oups: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := (Smalltalk at: #chose) createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	uneEssence getDifferentia add: attribut.	attribut isSituation: false.	attribut isPrototype: aBoolean.		attribut setDescription: 'definitionAttribut: ', unStringOrSymbol printString, ' de: ', uneEssence getNom printString, ' isProtype ', aBoolean printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:17'!definitionAttribut: unStringOrSymbol de: uneEssence genus: uneAutreEssence	"définition dans le differentia de une essence d'une essence subsumée	par uneAutreEssence"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			self oups: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := uneAutreEssence createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	attribut isSituation: false.	uneEssence getDifferentia add: attribut.	attribut setDescription: 'definitionAttribut: ', unStringOrSymbol printString, ' de: ', uneEssence getNom printString, ' genus: ', uneAutreEssence printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:22'!definitionQualite: unStringOrSymbol situation: uneSituation genus: uneEssence	"définition dans uneSituation d'une manière d'être subsumée par uneEssence "	| nom essence |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneSituation getElements		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			self oups: 'une essence nommée ''' , x getNom, ''' existe déjà dans '				, uneSituation getNom ].	essence := uneEssence createFreeSubclass: nom.	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneSituation.	uneSituation getDifferentia add: essence.	essence isSituation: false.	essence isQualite: true.	essence setStatut: #accidentelle.	essence setEffectivite: #intermittente.	essence setDescription: 'definitionQualite: ', unStringOrSymbol printString, ' situation: ', uneSituation getNom printString, ' genus: ', uneEssence getNom printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:28'!definitionSituation: unStringOrSymbol 	"définition dans absolu  d'une situation générique subsumée par Essence "	| sg nom |	nom := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	(Smalltalk at: #absolu)  getSituations		detect: [:each | each getNom == nom]		ifFound: [:x | self oups: 'une situation nommée ''' , x getNom, ''' existe déjà dans ' , #absolu].	sg := Essence createFreeSubclass: nom.	(Smalltalk at: #absolu) getDifferentia add: sg.	(Smalltalk at: #Lexique)		add: nom.	sg isSituation: true.	Smalltalk at: nom asSymbol put: sg.	sg setDescription: 'definitionSituation: ', unStringOrSymbol printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:26'!definitionQualiteEssentielle: unStringOrSymbol pour: uneEssence effectivite: unSymbole	"définition dans la situation de définition de uneEssence d'une manière d'être essentielle subsumée par chose "	| nom essence s col |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	s := uneEssence getSituationDefinition.	s isSituation		ifTrue: [ col := s getElements ]		ifFalse: [ col := s getEssencesAttributs ].	col detect: [ :each | each getNom == nom ] ifFound: [ :x |		self oups:			'une essence nommée ''' , x getNom , ''' existe déjà dans '			, s getNom ].	essence := (Smalltalk at: #chose) createFreeSubclass: nom.	"uneEssence getDifferentia add: essence."	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneEssence.	essence isSituation: false.	essence isQualite: true.	essence setStatut: #essentielle.	essence setEffectivite: unSymbole.	uneEssence getQualitesPropres add: essence.	essence getEssencesQualifiees add: uneEssence.	essence setDescription: 'definitionQualite: ', unStringOrSymbol printString, ' pour: ', uneEssence getNom printString, ' effectivite: ', unSymbole printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:29'!definitionSituation: unStringOrSymbol dans: uneSituationGenerique	"définition dans uneSituationGenerique d'une situation générique subsumée par Essence "	| sg nom |	nom := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	(Smalltalk at: #absolu)  getSituations		detect: [:each | each getNom == nom]		ifFound: [:x | self oups: 'une situation nommée ''' , x getNom, ''' existe déjà dans ' , #absolu].	sg := Essence  createFreeSubclass: nom.	uneSituationGenerique getDifferentia add: sg.	(Smalltalk at: #Lexique)		add: nom.	sg isSituation: true.	Smalltalk at: nom asSymbol put: sg.	sg setDescription: 'definitionSituation: ', unStringOrSymbol printString, ' dans: ', uneSituationGenerique getNom printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:17'!definitionAttribut: unStringOrSymbol de: uneEssence genus: uneAutreEssence cardinalite: uneValeur	"définition dans le differentia de une essence d'une essence subsumée	par uneAutreEssence"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			self oups: 'une essence nommée ''' , x getNom				, ''' existe déjà dans le differentia de ' , uneEssence getNom ].	attribut := uneAutreEssence createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	attribut isSituation: false.	attribut setCardinalite: uneValeur.	uneEssence getDifferentia add: attribut.	attribut isSituation: false.	attribut setDescription: 'definitionAttribut: ', unStringOrSymbol printString, ' de: ', uneEssence getNom printString, ' genus: ', uneAutreEssence printString, ' cardinalité: ', uneValeur printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 13:07'!definition: unStringOrSymbol genus: uneEssence 	"définition dans absolu  d'une essence subsumée par uneEssence"	| nom essence | 	nom := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	(nom at: 1) isLowercase ifFalse: [self oups: 'le nom commun d''une essence doit commencer par une minuscule'].	(Smalltalk at: #absolu)  getElements		detect: [:each | each getNom == nom]		ifFound: [:x | self oups: 'une essence nommée ''' , x getNom, ''' existe déjà dans l''absolu'].	essence := uneEssence createFreeSubclass: nom.	(Smalltalk at: #Lexique)		add: nom.	Smalltalk		at: nom		put: essence.	essence setSituationDefinition: (Smalltalk at: #absolu).	(Smalltalk at: #absolu) getDifferentia add: essence.	essence isSituation: false.	essence isQualite: false.	essence setDescription: 'definition: ', unStringOrSymbol printString, ' genus: ', uneEssence getNom printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:25'!definitionQualiteEssentielle: unStringOrSymbol genus: uneEssence pour: uneAutreEssence effectivite: unSymbole	"définition dans la situation de définition de uneEssence d'une manière d'être essentielle subsumée par chose "	| nom essence s col |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	s := uneAutreEssence getSituationDefinition.	s isSituation		ifTrue: [ col := s getElements ]		ifFalse: [ col := s getEssencesAttributs ].	col detect: [ :each | each getNom == nom ] ifFound: [ :x |		self oups:			'une essence nommée ''' , x getNom , ''' existe déjà dans '			, s getNom ].	essence := uneEssence createFreeSubclass: nom.	"uneAutreEssence getDifferentia add: essence."	(Smalltalk at: #Lexique) add: nom.	essence setSituationDefinition: uneAutreEssence.	essence isSituation: false.	essence isQualite: true.	essence setStatut: #essentielle.	essence setEffectivite: unSymbole.	uneAutreEssence getQualitesPropres add: essence.	essence getEssencesQualifiees add: uneAutreEssence.	essence setDescription: 'definitionQualite: ', unStringOrSymbol printString, ' genus: ', uneEssence getNom printString, ' pour: ', uneAutreEssence getNom printString, ' effectivite: ', unSymbole printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:14'!definitionAttribut: unStringOrSymbol de: uneEssence	"définition dans le differentia de une essence d'une essence subsumée par chose"	| attribut nom |	nom := unStringOrSymbol isSymbol		       ifTrue: [ unStringOrSymbol ]		       ifFalse: [ unStringOrSymbol asSymbol ].	(nom at: 1) isLowercase ifFalse: [		self oups:			'le nom commun d''une essence doit commencer par une minuscule' ].	uneEssence getDifferentia		detect: [ :each | each getNom == nom ]		ifFound: [ :x |			self oups:				'une essence nommée ''' , x getNom , ''' existe déjà dans le differentia de '				, uneEssence getNom ].	attribut := (Smalltalk at: #chose) createFreeSubclass: nom.	attribut setSituationDefinition: uneEssence.	uneEssence getDifferentia add: attribut.	attribut isSituation: false.	attribut setDescription: 'definitionAttribut: ', unStringOrSymbol printString, ' de: ', uneEssence getNom printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'definitions' stamp: 'RB 3/28/2024 17:11'!definition: unStringOrSymbol situation: uneSituation genus: uneEssence 	"définition dans uneSituation d'une essence subsumée par uneEssence"	| nom essence |	nom := unStringOrSymbol isSymbol				ifTrue: [unStringOrSymbol]				ifFalse: [unStringOrSymbol asSymbol].	(nom at: 1) isLowercase ifFalse: [self oups: 'le nom commun d''une essence doit commencer par une minuscule'].	uneSituation getElements		detect: [:each | each getNom == nom]		ifFound: [:x | self oups: 'une essence nommée ''' , x getNom , ''' existe déjà dans ' , uneSituation getNom].	essence := uneEssence createFreeSubclass: nom.	(Smalltalk at: #Lexique)		add: nom.	essence setSituationDefinition: uneSituation.	uneSituation getDifferentia add: essence.	essence isSituation: false.	essence isQualite: false.	essence setDescription: 'definition: ', unStringOrSymbol printString, ' situation: ', uneSituation getNom printString, ' genus: ', uneEssence getNom printString.	Smalltalk at: #sgb ifPresent: [:x | x window close]! !!ICEO methodsFor: 'utile' stamp: 'RB 3/19/2024 09:39'!oups: unString	Essence oups: unString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICEO class	instanceVariableNames: ''!!ICEO class methodsFor: 'worldMenu' stamp: 'RB 3/26/2024 14:43'!addSiBrowser: aBuilder<worldMenu>| sibr |			(aBuilder item: #SiBrowser)				parent: #ICEO;				order: 2;				help: 'Open a SiBrowser';				iconName: #glamorousInspect;				label: 'SiBrowser';				action: [ sibr := SiBrowser new. Smalltalk at: #sib put: sibr. sibr open ];				withSeparatorAfter ! !!ICEO class methodsFor: 'worldMenu' stamp: 'RobertBourgeois 3/25/2024 20:55'!addReset: aBuilder<worldMenu>			(aBuilder item: #Reset)				parent: #ICEO;				order: 3;				help: 'Reset ICEO';				iconName: #glamorousTrash;				label: 'Iceo reset';				action: [ ICEO reset ];				withSeparatorAfter ! !!ICEO class methodsFor: 'worldMenu' stamp: 'RB 3/26/2024 14:43'!addSgBrowser: aBuilder<worldMenu>| sgbr |			(aBuilder item: #SgBrowser)				parent: #ICEO;				order: 1;				help: 'Open a SgBrowser';				iconName: #glamorousInspect;				label: 'SgBrowser';				action: [ sgbr := SgBrowser new. Smalltalk at: #sgb put: sgbr. sgbr open ];				withSeparatorAfter ! !!ICEO class methodsFor: 'worldMenu' stamp: 'RobertBourgeois 3/25/2024 12:22'!ajoute: aBuilder	<worldMenu>	(aBuilder item: #ICEO)		order: 5! !!ICEO class methodsFor: 'utile' stamp: 'RB 3/3/2024 07:55'!getPremierGenusCommun: uneCollectionEssences 	"il faudra étendre cette méthode à un nombre d'essences > 2 !! "	| c t1 t2 |	c := uneCollectionEssences.	c size == 1		ifTrue: [^ c at: 1].	t1 := (c at: 1) getAllGenus.	t2 := (c at: 2) getAllGenus.	t1		detect: [:each | t2 includes: each]		ifFound: [:x | ^ x].   "il y a au moins l'essence chose !! "! !!ICEO class methodsFor: 'utile' stamp: 'RB 3/28/2024 21:20'!forDoIt	"Permet que les lignes évaluées en bloc soient évaluées en séquence"	RubSmalltalkEditor		compile: 'evaluateSelection	| node | 	node := RBParser parseExpression: self selectionAsStream contents.	node class == RBMessageNode ifTrue: [			OpalCompiler new evaluate:  node newSource ].  	node class == RBSequenceNode ifTrue: [		node statements do: [ :each | 			Semaphore new				wait: (Duration milliSeconds: 10)				onCompletion: []				onTimeout: [ 						OpalCompiler new evaluate:  each newSource]]]'		classified: 'do-it'! !!ICEO class methodsFor: 'private' stamp: 'RB 3/28/2024 13:32'!start	| abs th wd |	"Appelée lors du chargement de ICEO.st"	ICEO forDoIt.	(Smalltalk globals hasClassNamed: 'absolu') ifTrue: [		Essence oups:			'ICEO start ne peut être utilisée qu''une seule fois. 		Utiliser ICEO reset' ].	Smalltalk at: #iceo put: self new.	Smalltalk at: #Lexique put: OrderedCollection new.	Smalltalk at: #GenSym put: Dictionary new.	abs := Essence createFreeSubclass: #absolu.	Smalltalk at: #absolu put: abs.	(Smalltalk at: #absolu) setDescription: 'absolu est la racine des situations génériques'.	abs isSituation: true.	abs isQualite: false.	th := Essence createFreeSubclass: #chose.	Smalltalk at: #chose put: th.	(Smalltalk at: #Lexique) add: #chose.	(Smalltalk at: #chose) setDescription: 'chose est l''essence racine de la hiérarchie des essences'.	th isSituation: false.	th isQualite: false.	th setSituationDefinition: abs.	wd := abs new.	wd setNom: #monde.	Smalltalk at: #monde put: wd.	(Smalltalk at: #Lexique) add: #monde.	wd isSituation: true.	wd isEtat: false.	Transcript		cr;		show: 'ICEO initialisé avec absolu, monde et chose'! !!ICEO class methodsFor: 'intialise' stamp: 'RB 3/27/2024 19:31'!reset	| abs th wd |	(Smalltalk at: #Lexique) do: [:each | Smalltalk globals removeKey: each ifAbsent: []].	Smalltalk at: #iceo put: self new.	Smalltalk at: #Lexique put: OrderedCollection new.	Smalltalk at: #GenSym put: Dictionary new.	Essence subclasses		do: [:each | Essence removeSubclass: each].	abs := Essence createFreeSubclass: #absolu.	Smalltalk at: #absolu put: abs.	(Smalltalk at: #absolu) setDescription: 'absolu est la racine des situations génériques'.	abs isSituation: true.	abs isQualite: false.	th := Essence createFreeSubclass: #chose.	Smalltalk at: #chose put: th.	(Smalltalk at: #chose) setDescription: 'chose est l''essence racine de la hiérarchie des essences'.	(Smalltalk at: #Lexique) add: #chose.	(Smalltalk at: #absolu) getDifferentia add: (Smalltalk at: #chose).	th isSituation: false.	th isQualite: false.	th setSituationDefinition: abs.	wd := abs new.	wd setNom: #monde.	Smalltalk at: #monde put: wd.	(Smalltalk at: #Lexique) add: #monde.	wd isSituation: true.	wd isEtat: false.	Smalltalk at: #sgb ifPresent: [:x | x window close].	Smalltalk at: #sib ifPresent: [:x | x window close]! !SpPresenter subclass: #SgBrowser	instanceVariableNames: 'situations essences attributs qualites code'	classVariableNames: ''	package: 'ICEO'!!SgBrowser commentStamp: 'RobertBourgeois 3/24/2024 11:07' prior: 0!Browser au niveau générique d'ICEO!!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/25/2024 20:48'!initializeSituationsPresenter	situations := self newTreeTable.	situations		addColumn: (SpCompositeTableColumn new				 addColumn: ((SpImageTableColumn evaluated: [ :aSituation |							   Smalltalk ui icons iconNamed: #open ])						  width: 20;						  yourself);				 addColumn: (SpStringTableColumn evaluated: #name);				 yourself);		roots: { (Smalltalk at: #absolu) };		children: [ :aSituation | aSituation getSituations ];		whenActivatedDo: [ :selection | 			selection selectedItem inspect ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/26/2024 07:37'!connectEssencesPresenter	essences		transmitTo: attributs		transform: [ :aClass | 			aClass				ifNotNil: [aClass getEssencesAttributs asArray]				ifNil: [ #(  ) ] ].			essences		transmitTo: qualites		transform: [ :aClass | 			aClass				ifNotNil: [aClass getQualites asArray]				ifNil: [ #(  ) ] ].		essences		transmitTo: code		transform: [ :aClass | aClass ifNotNil: [ aClass getDescription ] ifNil: [ '' ] ]! !!SgBrowser methodsFor: 'initialization'!classTemplateFor: aSituation	aSituation ifNil: [ ^ '' ].	^ 'Object subclass: #NameOfSubclass	slots: {}	classVariables: {}	package: ''' , aSituation name , ''' '! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 15:42'!connectQualitesPresenter	qualites		transmitTo: code		transform: [ :aQualite | aQualite ifNotNil: [ aQualite getDescription ] ifNil: [ '' ] ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:03'!initializeCodePresenter	code := self newLabel ! !!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/25/2024 21:13'!initializeEssencesPresenter	| icon |	essences := self newList.	essences		display: [ :essence | essence name ];				displayIcon: [ :essence |			essence isQualite   				ifTrue: [					essence isEssentielle						ifTrue: [ icon := Smalltalk ui icons iconNamed: #testRed ] 						ifFalse: [ icon := Smalltalk ui icons iconNamed: #testYellow ]]			ifFalse: [ icon := Smalltalk ui icons iconNamed: #testGreen]. 			icon]; 			whenActivatedDo: [ :selection | 			selection selectedItem inspect ];		sortingBlock: [ :a :b | a name < b name ]	! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 16:10'!initializeQualitesPresenter| icon |	qualites := self newList.	qualites		display: [ :qualite | qualite  name ];				displayIcon: [ :essence | 			essence isQualite   				ifTrue: [					essence isEssentielle						ifTrue: [ icon := Smalltalk ui icons iconNamed: #testRed ] 						ifFalse: [ icon := Smalltalk ui icons iconNamed: #testYellow ]]			ifFalse: [ icon := Smalltalk ui icons iconNamed: #testGreen]. 			icon]; 		whenActivatedDo: [ :selection | selection selectedItem inspect ];		sortingBlock: [ :a :b | a name < b name ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 3/27/2024 09:36'!initializeWindow: aWindowPresenter	aWindowPresenter		title: 'Niveau générique';		initialExtent: 800 @ 250! !!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/26/2024 10:49'!connectSituationsPresenter	situations transmitTo: essences transform: [ :aSituation |		aSituation			ifNotNil: [ aSituation getEssences asArray ]			ifNil: [ #(  ) ] ].	situations transmitTo: code transform: [ :aSituation |		aSituation isNil			ifFalse: [ aSituation getDescription ]			ifTrue: [ '' ] ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/24/2024 18:22'!initializePresenters	self initializeSituationsPresenter.	self initializeEssencesPresenter.	self initializeAttributsPresenter.	self initializeQualitesPresenter.	self initializeCodePresenter! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:50'!connectAttributsPresenter	attributs		transmitTo: code		transform: [ :aAttribut | aAttribut ifNotNil: [ aAttribut getDescription ] ifNil: [ '' ] ]! !!SgBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/25/2024 20:45'!connectPresenters	self connectSituationsPresenter.	self connectEssencesPresenter.	self connectAttributsPresenter.	self connectQualitesPresenter! !!SgBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 15:51'!initializeAttributsPresenter	| icon |	attributs := self newList.	attributs		display: [ :attribut |			attribut getSituationDefinition isSituation				ifTrue: [ attribut name ]				ifFalse: [					attribut name , ' de '					, attribut getSituationDefinition printString ] ];		displayIcon: [ :essence |			essence isQualite				ifTrue: [					essence isEssentielle						ifTrue: [ icon := Smalltalk ui icons iconNamed: #testRed ]						ifFalse: [ icon := Smalltalk ui icons iconNamed: #testYellow ] ]				ifFalse: [					essence isAttributPropre						ifTrue: [ icon := Smalltalk ui icons iconNamed: #testGreen ]						ifFalse: [ icon := Smalltalk ui icons iconNamed: #testGreen ] ].			icon ];		whenActivatedDo: [ :selection | selection selectedItem inspect ];		sortingBlock: [ :a :b | a name < b name ]! !!SgBrowser methodsFor: 'layout' stamp: 'RB 3/26/2024 13:44'!defaultLayout	| situationsLayout essencesLayout qualitesLayout attributsLayout |	situationsLayout := SpBoxLayout newTopToBottom		add: 'Situations' expand: false;		add: situations;		yourself.		essencesLayout := SpBoxLayout newTopToBottom		add: 'Essences' expand: false;		add: essences;		yourself.			attributsLayout := SpBoxLayout newTopToBottom		add: 'Attributs' expand: false;		add: attributs;		yourself.			qualitesLayout := SpBoxLayout newTopToBottom		add: 'Qualités' expand: false;		add: qualites;		yourself.			^ SpBoxLayout newTopToBottom		spacing: 5;		add: (SpBoxLayout newLeftToRight			spacing: 5;			add: situationsLayout;			add: essencesLayout;			add: attributsLayout;			add: qualitesLayout;			yourself);			add: code height: 30;		yourself! !!SgBrowser methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 10:36'!getSituations^situations! !!SgBrowser methodsFor: 'acces' stamp: 'RobertBourgeois 3/26/2024 10:25'!getEssences^essences! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SgBrowser class	instanceVariableNames: ''!!SgBrowser class methodsFor: 'showing'!open 	<script>		^ self new open! !SpPresenter subclass: #SiBrowser	instanceVariableNames: 'situations etres attributs etats code'	classVariableNames: ''	package: 'ICEO'!!SiBrowser commentStamp: 'RobertBourgeois 3/24/2024 11:07' prior: 0!Browser au niveau individuel d'ICEO!!SiBrowser methodsFor: 'layout' stamp: 'RB 3/26/2024 13:46'!defaultLayout	| situationsLayout etresLayout etatsLayout attributsLayout |	situationsLayout := SpBoxLayout newTopToBottom		add: 'Situations' expand: false;		add: situations;		yourself.		etresLayout := SpBoxLayout newTopToBottom		add: 'Etres' expand: false;		add: etres;		yourself.			attributsLayout := SpBoxLayout newTopToBottom		add: 'Attributs' expand: false;		add: attributs;		yourself.			etatsLayout := SpBoxLayout newTopToBottom		add: 'Etats' expand: false;		add: etats;		yourself.			^ SpBoxLayout newTopToBottom		spacing: 5;		add: (SpBoxLayout newLeftToRight			spacing: 5;			add: situationsLayout;			add: etresLayout;			add: attributsLayout;			add: etatsLayout;			yourself);			add: code height: 30;		yourself! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:45'!connectEtresPresenter	etres		transmitTo: attributs		transform: [ :anEtre | 			anEtre				ifNotNil: [anEtre getEtresAttributs asArray]				ifNil: [ #(  ) ] ].			etres		transmitTo: etats		transform: [ :anEtre | 			anEtre				ifNotNil: [anEtre getEtats asArray]				ifNil: [ #(  ) ] ].		etres		transmitTo: code		transform: [ :anEtre | anEtre ifNotNil: [ anEtre getDescription ] ifNil: [ '' ] ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/25/2024 14:00'!initializeSituationsPresenter	situations := self newTreeTable.	situations		addColumn: (SpCompositeTableColumn new				 addColumn: ((SpImageTableColumn evaluated: [ :aSituation |							   Smalltalk ui icons iconNamed: #open ])						  width: 20;						  yourself);				 addColumn: (SpStringTableColumn evaluated: #getNom);				 yourself);		roots: { (Smalltalk at: #monde) };		children: [ :aSituation | aSituation getSituations ];		whenActivatedDo: [ :selection | 			selection selectedItem inspect ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:45'!initializeCodePresenter	code := self newLabel! !!SiBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/25/2024 14:32'!initializeAttributsPresenter| icon |	attributs := self newList.	attributs		display: [ :attribut | attribut  getNom ];		displayIcon: [ :etre |			etre isEtat   				ifTrue: [					etre class isEssentielle						ifTrue: [ icon := Smalltalk ui icons iconNamed: #glamorousRedCircle ] 						ifFalse: [ icon := Smalltalk ui icons iconNamed: #protocolProtected ]]			ifFalse: [ icon := Smalltalk ui icons iconNamed: #glamorousGreenCircle]. 			icon]; 		whenActivatedDo: [ :selection | 			selection selectedItem inspect ];		sortingBlock: [ :a :b | a getNom < b getNom ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/27/2024 09:37'!initializeWindow: aWindowPresenter	aWindowPresenter		title: 'Niveau individuel';		initialExtent: 800 @ 250! !!SiBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/25/2024 14:26'!initializeEtresPresenter	| icon |	etres := self newList.	etres		display: [ :etre | etre getNom ];				displayIcon: [ :etre |			etre isEtat   				ifTrue: [					etre class isEssentielle						ifTrue: [ icon := Smalltalk ui icons iconNamed: #glamorousRedCircle ] 						ifFalse: [ icon := Smalltalk ui icons iconNamed: #protocolProtected ]]			ifFalse: [ icon := Smalltalk ui icons iconNamed: #glamorousGreenCircle]. 			icon]; 			whenActivatedDo: [ :selection | 			selection selectedItem inspect ];		sortingBlock: [ :a :b | a getNom < b getNom ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:45'!connectSituationsPresenter	situations		transmitTo: etres		transform: [ :aSituation | 			aSituation				ifNotNil: [ aSituation getEtres asArray ] 				ifNil: [ #(  ) ] ].	situations		transmitTo: code		transform: [ :aSituation | aSituation getDescription ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/24/2024 18:22'!initializePresenters	self initializeSituationsPresenter.	self initializeEtresPresenter.	self initializeAttributsPresenter.	self initializeEtatsPresenter.	self initializeCodePresenter! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:46'!connectEtatsPresenter	etats		transmitTo: code		transform: [ :anEtat | anEtat ifNotNil: [ anEtat getDescription ] ifNil: [ '' ] ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RB 3/26/2024 13:46'!connectAttributsPresenter	attributs		transmitTo: code		transform: [ :aAttribut | aAttribut ifNotNil: [ aAttribut getDescription ] ifNil: [ '' ] ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/25/2024 14:36'!initializeEtatsPresenter| icon |	etats := self newList.	etats		display: [ :etat | etat  getNom ];		displayIcon: [ :etre |			etre isEtat   				ifTrue: [					etre class isEssentielle						ifTrue: [ icon := Smalltalk ui icons iconNamed: #glamorousRedCircle ] 						ifFalse: [ icon := Smalltalk ui icons iconNamed: #protocolProtected ]]			ifFalse: [ icon := Smalltalk ui icons iconNamed: #glamorousGreenCircle]. 			icon]; 			whenActivatedDo: [ :selection | 			selection selectedItem inspect ];		sortingBlock: [ :a :b | a getNom < b getNom ]! !!SiBrowser methodsFor: 'initialization' stamp: 'RobertBourgeois 3/24/2024 18:18'!connectPresenters	self connectSituationsPresenter.	self connectEtresPresenter.	self connectAttributsPresenter.	self connectEtatsPresenter! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SiBrowser class	instanceVariableNames: ''!!SiBrowser class methodsFor: 'showing'!open 	<script>		^ self new open! !	"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICEO start !